<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.2. Device Memory</title><link rel="stylesheet" type="text/css" href="config/vkspec-xhtml.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Vulkan 1.0.30 - A Specification (with WSI extensions)" /><link rel="up" href="ch10.html" title="Chapter 10. Memory Allocation" /><link rel="prev" href="ch10s01.html" title="10.1. Host Memory" /><link rel="next" href="ch11.html" title="Chapter 11. Resource Creation" /><script xmlns="" type="text/x-mathjax-config">
        MathJax.Hub.Config({
            MathML: { extensions: ["content-mathml.js"] },
            tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] }
        });
    </script><script xmlns="" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch10s01.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch11.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="memory-device"></a>10.2. Device Memory</h2></div></div></div><p>Device memory is memory that is visible to the device, for example the
contents of opaque images that <span class="normative">can</span> be natively used by the device, or
uniform buffer objects that reside in on-device memory.</p><p>Memory properties of a physical device describe the memory heaps and memory
types available.</p><p>To query memory properties, call:</p><p><a id="vkGetPhysicalDeviceMemoryProperties"></a><strong> </strong>
</p><pre class="programlisting">void vkGetPhysicalDeviceMemoryProperties(
    VkPhysicalDevice                            physicalDevice,
    VkPhysicalDeviceMemoryProperties*           pMemoryProperties);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>physicalDevice</code></em> is the handle to the device to query.
</li><li class="listitem">
<em class="parameter"><code>pMemoryProperties</code></em> points to an instance of
    <code class="code">VkPhysicalDeviceMemoryProperties</code> structure in which the properties
    are returned.
</li></ul></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>physicalDevice</code></em> <span class="normative">must</span> be a valid <code class="code">VkPhysicalDevice</code> handle
</li><li class="listitem">
<em class="parameter"><code>pMemoryProperties</code></em> <span class="normative">must</span> be a pointer to a <code class="code">VkPhysicalDeviceMemoryProperties</code> structure
</li></ul></div></div><p>The <code class="code">VkPhysicalDeviceMemoryProperties</code> structure is defined as:</p><p><a id="VkPhysicalDeviceMemoryProperties"></a><strong> </strong>
</p><pre class="programlisting">typedef struct VkPhysicalDeviceMemoryProperties {
    uint32_t        memoryTypeCount;
    VkMemoryType    memoryTypes[VK_MAX_MEMORY_TYPES];
    uint32_t        memoryHeapCount;
    VkMemoryHeap    memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>memoryTypeCount</code></em> is the number of valid elements in the
    <em class="parameter"><code>memoryTypes</code></em> array.
</li><li class="listitem">
<em class="parameter"><code>memoryTypes</code></em> is an array of <code class="code"><a class="link" href="ch10s02.html#VkMemoryType">VkMemoryType</a></code> structures
    describing the <span class="emphasis"><em>memory types</em></span> that <span class="normative">can</span> be used to access memory
    allocated from the heaps specified by <em class="parameter"><code>memoryHeaps</code></em>.
</li><li class="listitem">
<em class="parameter"><code>memoryHeapCount</code></em> is the number of valid elements in the
    <em class="parameter"><code>memoryHeaps</code></em> array.
</li><li class="listitem">
<em class="parameter"><code>memoryHeaps</code></em> is an array of <code class="code"><a class="link" href="ch10s02.html#VkMemoryHeap">VkMemoryHeap</a></code> structures
    describing the <span class="emphasis"><em>memory heaps</em></span> from which memory <span class="normative">can</span> be allocated.
</li></ul></div><p>The <code class="code">VkPhysicalDeviceMemoryProperties</code> structure describes a number of
<span class="emphasis"><em>memory heaps</em></span> as well as a number of <span class="emphasis"><em>memory types</em></span> that <span class="normative">can</span> be used to
access memory allocated in those heaps.
Each heap describes a memory resource of a particular size, and each memory
type describes a set of memory properties (e.g. host cached vs uncached)
that <span class="normative">can</span> be used with a given memory heap.
Allocations using a particular memory type will consume resources from the
heap indicated by that memory type’s heap index.
More than one memory type <span class="normative">may</span> share each heap, and the heaps and memory
types provide a mechanism to advertise an accurate size of the physical
memory resources while allowing the memory to be used with a variety of
different properties.</p><p>The number of memory heaps is given by <em class="parameter"><code>memoryHeapCount</code></em> and is less
than or equal to <code class="code">VK_MAX_MEMORY_HEAPS</code>.
Each heap is described by an element of the <em class="parameter"><code>memoryHeaps</code></em> array, as a
<code class="code">VkMemoryHeap</code> structure.
The number of memory types available across all memory heaps is given by
<em class="parameter"><code>memoryTypeCount</code></em> and is less than or equal to
<code class="code">VK_MAX_MEMORY_TYPES</code>.
Each memory type is described by an element of the <em class="parameter"><code>memoryTypes</code></em> array,
as a <code class="code">VkMemoryType</code> structure.</p><p>At least one heap <span class="normative">must</span> include <code class="code">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code> in
<code class="code"><a class="link" href="ch10s02.html#VkMemoryHeap">VkMemoryHeap</a></code>::<em class="parameter"><code>flags</code></em>.
If there are multiple heaps that all have similar performance
characteristics, they <span class="normative">may</span> all include
<code class="code">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code>.
In a unified memory architecture (UMA) system, there is often only a single
memory heap which is considered to be equally “local” to the host and to
the device, and such an implementation <span class="normative">must</span> advertise the heap as
device-local.</p><p>Each memory type returned by <code class="code"><a class="link" href="ch10s02.html#vkGetPhysicalDeviceMemoryProperties">vkGetPhysicalDeviceMemoryProperties</a></code> <span class="normative">must</span>
have its <em class="parameter"><code>propertyFlags</code></em> set to one of the following values:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
0
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code>
</li><li class="listitem">
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> |
    <code class="code">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>
</li></ul></div><p>There <span class="normative">must</span> be at least one memory type with both the
<code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> and
<code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> bits set in its
<em class="parameter"><code>propertyFlags</code></em>.
There <span class="normative">must</span> be at least one memory type with the
<code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> bit set in its
<em class="parameter"><code>propertyFlags</code></em>.</p><p>The memory types are sorted according to a preorder which serves to aid in
easily selecting an appropriate memory type.
Given two memory types X and Y, the preorder defines <span class="eq">X ≤ Y</span> if:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
the memory property bits set for X are a strict subset of the memory
    property bits set for Y.
    Or,
</li><li class="listitem">
the memory property bits set for X are the same as the memory property
    bits set for Y, and X uses a memory heap with greater or equal
    performance (as determined in an implementation-specific manner).
</li></ul></div><p>Memory types are ordered in the list such that X is assigned a lesser
<em class="parameter"><code>memoryTypeIndex</code></em> than Y if <span class="eq">(X ≤ Y) ∧ ¬ (Y ≤ X)</span>
according to the preorder.
Note that the list of all allowed memory property flag combinations above
satisfies this preorder, but other orders would as well.
The goal of this ordering is to enable applications to use a simple search
loop in selecting the proper memory type, along the lines of:</p><pre class="programlisting">// Find a memory type in "memoryTypeBits" that includes all of "properties"
int32_t FindProperties(uint32_t memoryTypeBits, VkMemoryPropertyFlags properties)
{
    for (int32_t i = 0; i &lt; memoryTypeCount; ++i)
    {
        if ((memoryTypeBits &amp; (1 &lt;&lt; i)) &amp;&amp;
            ((memoryTypes[i].propertyFlags &amp; properties) == properties))
            return i;
    }
    return -1;
}

// Try to find an optimal memory type, or if it does not exist
// find any compatible memory type
VkMemoryRequirements memoryRequirements;
vkGetImageMemoryRequirements(device, image, &amp;memoryRequirements);
int32_t memoryType = FindProperties(memoryRequirements.memoryTypeBits, optimalProperties);
if (memoryType == -1)
    memoryType = FindProperties(memoryRequirements.memoryTypeBits, requiredProperties);</pre><p>The loop will find the first supported memory type that has all bits
requested in <span class="strong"><strong><code class="code">properties</code></strong></span> set.
If there is no exact match, it will find a closest match (i.e. a memory type
with the fewest additional bits set), which has some additional bits set but
which are not detrimental to the behaviors requested by <span class="strong"><strong><code class="code">properties</code></strong></span>.
The application <span class="normative">can</span> first search for the optimal properties, e.g. a memory
type that is device-local or supports coherent cached accesses, as
appropriate for the intended usage, and if such a memory type is not present
<span class="normative">can</span> fallback to searching for a less optimal but guaranteed set of
properties such as "0" or "host-visible and coherent".</p><p>The <code class="code">VkMemoryHeap</code> structure is defined as:</p><p><a id="VkMemoryHeap"></a><strong> </strong>
</p><pre class="programlisting">typedef struct VkMemoryHeap {
    VkDeviceSize         size;
    VkMemoryHeapFlags    flags;
} VkMemoryHeap;</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>size</code></em> is the total memory size in bytes in the heap.
</li><li class="listitem"><p class="simpara">
<em class="parameter"><code>flags</code></em> is a bitmask of attribute flags for the heap.
    The bits specified in <em class="parameter"><code>flags</code></em> are:
</p><p><a id="VkMemoryHeapFlagBits"></a><strong> </strong>
</p><pre class="programlisting">typedef enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0x00000001,
} VkMemoryHeapFlagBits;</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
if <em class="parameter"><code>flags</code></em> contains <code class="code">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code>, it means
     the heap corresponds to device local memory.
     Device local memory <span class="normative">may</span> have different performance characteristics
     than host local memory, and <span class="normative">may</span> support different memory property
     flags.
</li></ul></div></li></ul></div><p>The <code class="code">VkMemoryType</code> structure is defined as:</p><p><a id="VkMemoryType"></a><strong> </strong>
</p><pre class="programlisting">typedef struct VkMemoryType {
    VkMemoryPropertyFlags    propertyFlags;
    uint32_t                 heapIndex;
} VkMemoryType;</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>heapIndex</code></em> describes which memory heap this memory type corresponds
    to, and <span class="normative">must</span> be less than <em class="parameter"><code>memoryHeapCount</code></em> from the
    <code class="code">VkPhysicalDeviceMemoryProperties</code> structure.
</li><li class="listitem"><p class="simpara">
<em class="parameter"><code>propertyFlags</code></em> is a bitmask of properties for this memory type.
    The bits specified in <em class="parameter"><code>propertyFlags</code></em> are:
</p><p><a id="VkMemoryPropertyFlagBits"></a><strong> </strong>
</p><pre class="programlisting">typedef enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0x00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0x00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0x00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0x00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0x00000010,
} VkMemoryPropertyFlagBits;</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
if <em class="parameter"><code>propertyFlags</code></em> has the
     <code class="code">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</code> bit set, memory allocated
     with this type is the most efficient for device access.
     This property will only be set for memory types belonging to heaps with
     the <code class="code">VK_MEMORY_HEAP_DEVICE_LOCAL_BIT</code> set.
</li><li class="listitem">
if <em class="parameter"><code>propertyFlags</code></em> has the
     <code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> bit set, memory allocated
     with this type <span class="normative">can</span> be mapped for host access using <code class="code"><a class="link" href="ch10s02.html#vkMapMemory">vkMapMemory</a></code>.
</li><li class="listitem">
if <em class="parameter"><code>propertyFlags</code></em> has the
     <code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> bit set, host cache
     management commands <span class="strong"><strong><code class="code">vkFlushMappedMemoryRanges</code></strong></span> and
     <span class="strong"><strong><code class="code">vkInvalidateMappedMemoryRanges</code></strong></span> are not needed to make host writes
     visible to the device or device writes visible to the host,
     respectively.
</li><li class="listitem">
if <em class="parameter"><code>propertyFlags</code></em> has the <code class="code">VK_MEMORY_PROPERTY_HOST_CACHED_BIT</code>
     bit set, memory allocated with this type is cached on the host.
     Host memory accesses to uncached memory are slower than to cached
     memory, however uncached memory is always host coherent.
</li><li class="listitem">
if <em class="parameter"><code>propertyFlags</code></em> has the
     <code class="code">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> bit set, the memory type
     only allows device access to the memory.
     Memory types <span class="normative">must</span> not have both
     <code class="code">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> and
     <code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> set.
     Additionally, the object’s backing memory <span class="normative">may</span> be provided by the
     implementation lazily as specified in <a class="link" href="ch10s02.html#memory-device-lazy_allocation" title="10.2.2. Lazily Allocated Memory">Lazily Allocated Memory</a>.
</li></ul></div></li></ul></div><p>A Vulkan device operates on data in device memory via memory objects that
are represented in the API by a <code class="code">VkDeviceMemory</code> handle.</p><p>Memory objects are represented by <code class="code">VkDeviceMemory</code> handles:</p><p><a id="VkDeviceMemory"></a><strong> </strong>
</p><pre class="programlisting">VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDeviceMemory)</pre><p>
</p><p>To allocate memory objects, call:</p><p><a id="vkAllocateMemory"></a><strong> </strong>
</p><pre class="programlisting">VkResult vkAllocateMemory(
    VkDevice                                    device,
    const VkMemoryAllocateInfo*                 pAllocateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkDeviceMemory*                             pMemory);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> is the logical device that owns the memory.
</li><li class="listitem">
<em class="parameter"><code>pAllocateInfo</code></em> is a pointer to an instance of the
    <code class="code"><a class="link" href="ch10s02.html#VkMemoryAllocateInfo">VkMemoryAllocateInfo</a></code> structure describing parameters of the
    allocation.
    A successful returned allocation <span class="normative">must</span> use the requested parameters —     no substitution is permitted by the implementation.
</li><li class="listitem">
<em class="parameter"><code>pAllocator</code></em> controls host memory allocation as described in the
    <a class="link" href="ch10s01.html#memory-allocation">Memory Allocation</a> chapter.
</li><li class="listitem">
<em class="parameter"><code>pMemory</code></em> is a pointer to a <code class="code">VkDeviceMemory</code> handle in which
    information about the allocated memory is returned.
</li></ul></div><p>Allocations returned by <span class="strong"><strong><code class="code">vkAllocateMemory</code></strong></span> are guaranteed to meet any
alignment requirement by the implementation.
For example, if an implementation requires 128 byte alignment for images and
64 byte alignment for buffers, the device memory returned through this
mechanism would be 128-byte aligned.
This ensures that applications <span class="normative">can</span> correctly suballocate objects of
different types (with potentially different alignment requirements) in the
same memory object.</p><p>When memory is allocated, its contents are undefined.</p><p>There is an implementation-dependent maximum number of memory allocations
which <span class="normative">can</span> be simultaneously created on a device.
This is specified by the
<a class="link" href="ch31s02.html#features-limits-maxMemoryAllocationCount"><em class="parameter"><code>maxMemoryAllocationCount</code></em></a>
member of the <code class="code">VkPhysicalDeviceLimits</code> structure.
If <em class="parameter"><code>maxMemoryAllocationCount</code></em> is exceeded, <span class="strong"><strong><code class="code">vkAllocateMemory</code></strong></span> will
return <code class="code">VK_ERROR_TOO_MANY_OBJECTS</code>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Some platforms <span class="normative">may</span> have a limit on the maximum size of a single allocation.
For example, certain systems <span class="normative">may</span> fail to create allocations with a size
greater than or equal to 4GB.
Such a limit is implementation-dependent, and if such a failure occurs then
the error <code class="code">VK_ERROR_OUT_OF_DEVICE_MEMORY</code> <span class="normative">should</span> be returned.</p></td></tr></table></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The number of currently valid memory objects, allocated from
    <em class="parameter"><code>device</code></em>, <span class="normative">must</span> be less than
    <code class="code">VkPhysicalDeviceLimits</code>::<em class="parameter"><code>maxMemoryAllocationCount</code></em>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> <span class="normative">must</span> be a valid <code class="code">VkDevice</code> handle
</li><li class="listitem">
<em class="parameter"><code>pAllocateInfo</code></em> <span class="normative">must</span> be a pointer to a valid <code class="code">VkMemoryAllocateInfo</code> structure
</li><li class="listitem">
If <em class="parameter"><code>pAllocator</code></em> is not <code class="literal">NULL</code>, <em class="parameter"><code>pAllocator</code></em> <span class="normative">must</span> be a pointer to a valid <code class="code">VkAllocationCallbacks</code> structure
</li><li class="listitem">
<em class="parameter"><code>pMemory</code></em> <span class="normative">must</span> be a pointer to a <code class="code">VkDeviceMemory</code> handle
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Return Codes</strong></p></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<a class="link" href="ch02s06.html#fundamentals-successcodes" title="Success Codes">Success</a>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VK_SUCCESS</code>
</li></ul></div></dd><dt><span class="term">
<a class="link" href="ch02s06.html#fundamentals-errorcodes" title="Error codes">Failure</a>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VK_ERROR_OUT_OF_HOST_MEMORY</code>
</li><li class="listitem">
<code class="code">VK_ERROR_OUT_OF_DEVICE_MEMORY</code>
</li><li class="listitem">
<code class="code">VK_ERROR_TOO_MANY_OBJECTS</code>
</li></ul></div></dd></dl></div></div><p>The <code class="code">VkMemoryAllocateInfo</code> structure is defined as:</p><p><a id="VkMemoryAllocateInfo"></a><strong> </strong>
</p><pre class="programlisting">typedef struct VkMemoryAllocateInfo {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceSize       allocationSize;
    uint32_t           memoryTypeIndex;
} VkMemoryAllocateInfo;</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>sType</code></em> is the type of this structure.
</li><li class="listitem">
<em class="parameter"><code>pNext</code></em> is <code class="literal">NULL</code> or a pointer to an extension-specific structure.
</li><li class="listitem">
<em class="parameter"><code>allocationSize</code></em> is the size of the allocation in bytes
</li><li class="listitem">
<em class="parameter"><code>memoryTypeIndex</code></em> is the memory type index, which selects the
    properties of the memory to be allocated, as well as the heap the memory
    will come from.
</li></ul></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>allocationSize</code></em> <span class="normative">must</span> be less than or equal to the amount of memory
    available to the <code class="code">VkMemoryHeap</code> specified by <em class="parameter"><code>memoryTypeIndex</code></em>
    and the calling command’s <code class="code">VkDevice</code>
</li><li class="listitem">
<em class="parameter"><code>allocationSize</code></em> <span class="normative">must</span> be greater than <code class="literal">0</code>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>sType</code></em> <span class="normative">must</span> be <code class="code">VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</code>
</li><li class="listitem">
<em class="parameter"><code>pNext</code></em> <span class="normative">must</span> be <code class="literal">NULL</code>
</li></ul></div></div><p>To free a memory object, call:</p><p><a id="vkFreeMemory"></a><strong> </strong>
</p><pre class="programlisting">void vkFreeMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    const VkAllocationCallbacks*                pAllocator);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> is the logical device that owns the memory.
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> is the <code class="code">VkDeviceMemory</code> object to be freed.
</li><li class="listitem">
<em class="parameter"><code>pAllocator</code></em> controls host memory allocation as described in the
    <a class="link" href="ch10s01.html#memory-allocation">Memory Allocation</a> chapter.
</li></ul></div><p>Before freeing a memory object, an application <span class="normative">must</span> ensure the memory
object is no longer in use by the device—for example by command buffers
queued for execution.
The memory <span class="normative">can</span> remain bound to images or buffers at the time the memory
object is freed, but any further use of them (on host or device) for
anything other than destroying those objects will result in undefined
behavior.
If there are still any bound images or buffers, the memory <span class="normative">may</span> not be
immediately released by the implementation, but <span class="normative">must</span> be released by the
time all bound images and buffers have been destroyed.
Once memory is released, it is returned to the heap from which it was
allocated.</p><p>How memory objects are bound to Images and Buffers is described in detail in
the <a class="link" href="ch11s06.html" title="11.6. Resource Memory Association">Resource Memory Association</a> section.</p><p>If a memory object is mapped at the time it is freed, it is implicitly
unmapped.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
All submitted commands that refer to <em class="parameter"><code>memory</code></em> (via images or
    buffers) <span class="normative">must</span> have completed execution
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> <span class="normative">must</span> be a valid <code class="code">VkDevice</code> handle
</li><li class="listitem">
If <em class="parameter"><code>memory</code></em> is not <code class="code"><a class="link" href="apds03.html#VK_NULL_HANDLE">VK_NULL_HANDLE</a></code>, <em class="parameter"><code>memory</code></em> <span class="normative">must</span> be a valid <code class="code">VkDeviceMemory</code> handle
</li><li class="listitem">
If <em class="parameter"><code>pAllocator</code></em> is not <code class="literal">NULL</code>, <em class="parameter"><code>pAllocator</code></em> <span class="normative">must</span> be a pointer to a valid <code class="code">VkAllocationCallbacks</code> structure
</li><li class="listitem">
If <em class="parameter"><code>memory</code></em> is a valid handle, it <span class="normative">must</span> have been created, allocated, or retrieved from <em class="parameter"><code>device</code></em>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Host Synchronization</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Host access to <em class="parameter"><code>memory</code></em> <span class="normative">must</span> be externally synchronized
</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="memory-device-hostaccess"></a>10.2.1. Host Access to Device Memory Objects</h3></div></div></div><p>Memory objects created with <span class="strong"><strong><code class="code">vkAllocateMemory</code></strong></span> are not directly host
accessible.</p><p>Memory objects created with the memory property
<code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code> are considered <span class="emphasis"><em>mappable</em></span>.
Memory objects <span class="normative">must</span> be mappable in order to be successfully mapped on the
host.</p><p>To retrieve a host virtual address pointer to a region of a mappable memory
object, call:</p><p><a id="vkMapMemory"></a><strong> </strong>
</p><pre class="programlisting">VkResult vkMapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    void**                                      ppData);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> is the logical device that owns the memory.
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> is the <code class="code">VkDeviceMemory</code> object to be mapped.
</li><li class="listitem">
<em class="parameter"><code>offset</code></em> is a zero-based byte offset from the beginning of the
    memory object.
</li><li class="listitem">
<em class="parameter"><code>size</code></em> is the size of the memory range to map, or
    <code class="code">VK_WHOLE_SIZE</code> to map from <em class="parameter"><code>offset</code></em> to the end of the
    allocation.
</li><li class="listitem">
<em class="parameter"><code>flags</code></em> is reserved for future use.
</li><li class="listitem">
<em class="parameter"><code>ppData</code></em> points to a pointer in which is returned a host-accessible
    pointer to the beginning of the mapped range.
    This pointer minus <em class="parameter"><code>offset</code></em> <span class="normative">must</span> be aligned to at least
    <code class="code">VkPhysicalDeviceLimits</code>::<em class="parameter"><code>minMemoryMapAlignment</code></em>.
</li></ul></div><p>It is an application error to call <span class="strong"><strong><code class="code">vkMapMemory</code></strong></span> on a memory object that
is already mapped.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p><span class="strong"><strong><code class="code">vkMapMemory</code></strong></span> will fail if the implementation is unable to allocate an
appropriately sized contiguous virtual address range, e.g. due to virtual
address space fragmentation or platform limits.
In such cases, <span class="strong"><strong><code class="code">vkMapMemory</code></strong></span> <span class="normative">must</span> return VK_ERROR_MEMORY_MAP_FAILED.
The application <span class="normative">can</span> improve the likelihood of success by reducing the size
of the mapped range and/or removing unneeded mappings using
<span class="strong"><strong><code class="code">VkUnmapMemory</code></strong></span>.</p></td></tr></table></div><p><a id="memory-device-hostaccess-hazards"></a><span class="strong"><strong><code class="code">vkMapMemory</code></strong></span> does not check whether the device memory is currently in
use before returning the host-accessible pointer.
The application <span class="normative">must</span> guarantee that any previously submitted command that
writes to this range has completed before the host reads from or writes to
that range, and that any previously submitted command that reads from that
range has completed before the host writes to that region (see
<a class="link" href="ch06s01.html#synchronization-fences-devicewrites">here</a> for details on fulfilling such
a guarantee).
If the device memory was allocated without the
<code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> set, these guarantees <span class="normative">must</span> be
made for an extended range: the application <span class="normative">must</span> round down the start of
the range to the nearest multiple of
<code class="code">VkPhysicalDeviceLimits</code>::<em class="parameter"><code>nonCoherentAtomSize</code></em>, and round the end
of the range up to the nearest multiple of
<code class="code">VkPhysicalDeviceLimits</code>::<em class="parameter"><code>nonCoherentAtomSize</code></em>.</p><p>While a range of device memory is mapped for host access, the application is
responsible for synchronizing both device and host access to that memory
range.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It is important for the application developer to become meticulously
familiar with all of the mechanisms described in the chapter on
<a class="link" href="ch06.html" title="Chapter 6. Synchronization and Cache Control">Synchronization and Cache Control</a> as they are crucial
to maintaining memory access ordering.</p></td></tr></table></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> not currently be mapped
</li><li class="listitem">
<em class="parameter"><code>offset</code></em> <span class="normative">must</span> be less than the size of <em class="parameter"><code>memory</code></em>
</li><li class="listitem">
If <em class="parameter"><code>size</code></em> is not equal to <code class="code">VK_WHOLE_SIZE</code>, <em class="parameter"><code>size</code></em> <span class="normative">must</span> be
    greater than <code class="literal">0</code>
</li><li class="listitem">
If <em class="parameter"><code>size</code></em> is not equal to <code class="code">VK_WHOLE_SIZE</code>, <em class="parameter"><code>size</code></em> <span class="normative">must</span> be
    less than or equal to the size of the <em class="parameter"><code>memory</code></em> minus <em class="parameter"><code>offset</code></em>
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> have been created with a memory type that reports
    <code class="code">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</code>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> <span class="normative">must</span> be a valid <code class="code">VkDevice</code> handle
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> be a valid <code class="code">VkDeviceMemory</code> handle
</li><li class="listitem">
<em class="parameter"><code>flags</code></em> <span class="normative">must</span> be <code class="literal">0</code>
</li><li class="listitem">
<em class="parameter"><code>ppData</code></em> <span class="normative">must</span> be a pointer to a pointer
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> have been created, allocated, or retrieved from <em class="parameter"><code>device</code></em>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Host Synchronization</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Host access to <em class="parameter"><code>memory</code></em> <span class="normative">must</span> be externally synchronized
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Return Codes</strong></p></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<a class="link" href="ch02s06.html#fundamentals-successcodes" title="Success Codes">Success</a>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VK_SUCCESS</code>
</li></ul></div></dd><dt><span class="term">
<a class="link" href="ch02s06.html#fundamentals-errorcodes" title="Error codes">Failure</a>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VK_ERROR_OUT_OF_HOST_MEMORY</code>
</li><li class="listitem">
<code class="code">VK_ERROR_OUT_OF_DEVICE_MEMORY</code>
</li><li class="listitem">
<code class="code">VK_ERROR_MEMORY_MAP_FAILED</code>
</li></ul></div></dd></dl></div></div><p>Two commands are provided to enable applications to work with non-coherent
memory allocations: <span class="strong"><strong><code class="code">vkFlushMappedMemoryRanges</code></strong></span> and
<span class="strong"><strong><code class="code">vkInvalidateMappedMemoryRanges</code></strong></span>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If the memory object was created with the
<code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> set,
<span class="strong"><strong><code class="code">vkFlushMappedMemoryRanges</code></strong></span> and <span class="strong"><strong><code class="code">vkInvalidateMappedMemoryRanges</code></strong></span> are
unnecessary and <span class="normative">may</span> have performance cost.</p></td></tr></table></div><p>To flush ranges of non-coherent memory from the host caches, call:</p><p><a id="vkFlushMappedMemoryRanges"></a><strong> </strong>
</p><pre class="programlisting">VkResult vkFlushMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> is the logical device that owns the memory ranges.
</li><li class="listitem">
<em class="parameter"><code>memoryRangeCount</code></em> is the length of the <em class="parameter"><code>pMemoryRanges</code></em> array.
</li><li class="listitem">
<em class="parameter"><code>pMemoryRanges</code></em> is a pointer to an array of
    <code class="code"><a class="link" href="ch10s02.html#VkMappedMemoryRange">VkMappedMemoryRange</a></code> structures describing the memory ranges to
    flush.
</li></ul></div><p><span class="strong"><strong><code class="code">vkFlushMappedMemoryRanges</code></strong></span> <span class="normative">must</span> be used to guarantee that host writes
to non-coherent memory are visible to the device.
It <span class="normative">must</span> be called after the host writes to non-coherent memory have
completed and before command buffers that will read or write any of those
memory locations are submitted to a queue.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> <span class="normative">must</span> be a valid <code class="code">VkDevice</code> handle
</li><li class="listitem">
<em class="parameter"><code>pMemoryRanges</code></em> <span class="normative">must</span> be a pointer to an array of <em class="parameter"><code>memoryRangeCount</code></em> valid <code class="code">VkMappedMemoryRange</code> structures
</li><li class="listitem">
<em class="parameter"><code>memoryRangeCount</code></em> <span class="normative">must</span> be greater than <code class="literal">0</code>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Return Codes</strong></p></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<a class="link" href="ch02s06.html#fundamentals-successcodes" title="Success Codes">Success</a>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VK_SUCCESS</code>
</li></ul></div></dd><dt><span class="term">
<a class="link" href="ch02s06.html#fundamentals-errorcodes" title="Error codes">Failure</a>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VK_ERROR_OUT_OF_HOST_MEMORY</code>
</li><li class="listitem">
<code class="code">VK_ERROR_OUT_OF_DEVICE_MEMORY</code>
</li></ul></div></dd></dl></div></div><p>To invalidate ranges of non-coherent memory from the host caches, call:</p><p><a id="vkInvalidateMappedMemoryRanges"></a><strong> </strong>
</p><pre class="programlisting">VkResult vkInvalidateMappedMemoryRanges(
    VkDevice                                    device,
    uint32_t                                    memoryRangeCount,
    const VkMappedMemoryRange*                  pMemoryRanges);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> is the logical device that owns the memory ranges.
</li><li class="listitem">
<em class="parameter"><code>memoryRangeCount</code></em> is the length of the <em class="parameter"><code>pMemoryRanges</code></em> array.
</li><li class="listitem">
<em class="parameter"><code>pMemoryRanges</code></em> is a pointer to an array of
    <code class="code"><a class="link" href="ch10s02.html#VkMappedMemoryRange">VkMappedMemoryRange</a></code> structures describing the memory ranges to
    invalidate.
</li></ul></div><p><span class="strong"><strong><code class="code">vkInvalidateMappedMemoryRanges</code></strong></span> <span class="normative">must</span> be used to guarantee that device
writes to non-coherent memory are visible to the host.
It <span class="normative">must</span> be called after command buffers that execute and flush (via memory
barriers) the device writes have completed, and before the host will read or
write any of those locations.
If a range of non-coherent memory is written by the host and then
invalidated without first being flushed, its contents are undefined.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> <span class="normative">must</span> be a valid <code class="code">VkDevice</code> handle
</li><li class="listitem">
<em class="parameter"><code>pMemoryRanges</code></em> <span class="normative">must</span> be a pointer to an array of <em class="parameter"><code>memoryRangeCount</code></em> valid <code class="code">VkMappedMemoryRange</code> structures
</li><li class="listitem">
<em class="parameter"><code>memoryRangeCount</code></em> <span class="normative">must</span> be greater than <code class="literal">0</code>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Return Codes</strong></p></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<a class="link" href="ch02s06.html#fundamentals-successcodes" title="Success Codes">Success</a>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VK_SUCCESS</code>
</li></ul></div></dd><dt><span class="term">
<a class="link" href="ch02s06.html#fundamentals-errorcodes" title="Error codes">Failure</a>
</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="code">VK_ERROR_OUT_OF_HOST_MEMORY</code>
</li><li class="listitem">
<code class="code">VK_ERROR_OUT_OF_DEVICE_MEMORY</code>
</li></ul></div></dd></dl></div></div><p>The <code class="code">VkMappedMemoryRange</code> structure is defined as:</p><p><a id="VkMappedMemoryRange"></a><strong> </strong>
</p><pre class="programlisting">typedef struct VkMappedMemoryRange {
    VkStructureType    sType;
    const void*        pNext;
    VkDeviceMemory     memory;
    VkDeviceSize       offset;
    VkDeviceSize       size;
} VkMappedMemoryRange;</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>sType</code></em> is the type of this structure.
</li><li class="listitem">
<em class="parameter"><code>pNext</code></em> is <code class="literal">NULL</code> or a pointer to an extension-specific structure.
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> is the memory object to which this range belongs.
</li><li class="listitem">
<em class="parameter"><code>offset</code></em> is the zero-based byte offset from the beginning of the
    memory object.
</li><li class="listitem">
<em class="parameter"><code>size</code></em> is either the size of range, or <code class="code">VK_WHOLE_SIZE</code> to affect
    the range from <em class="parameter"><code>offset</code></em> to the end of the current mapping of the
    allocation.
</li></ul></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> currently be mapped
</li><li class="listitem">
If <em class="parameter"><code>size</code></em> is not equal to <code class="code">VK_WHOLE_SIZE</code>, <em class="parameter"><code>offset</code></em> and
    <em class="parameter"><code>size</code></em> <span class="normative">must</span> specify a range contained within the currently mapped
    range of <em class="parameter"><code>memory</code></em>
</li><li class="listitem">
If <em class="parameter"><code>size</code></em> is equal to <code class="code">VK_WHOLE_SIZE</code>, <em class="parameter"><code>offset</code></em> <span class="normative">must</span> be
    within the currently mapped range of <em class="parameter"><code>memory</code></em>
</li><li class="listitem">
<em class="parameter"><code>offset</code></em> <span class="normative">must</span> be a multiple of
    <code class="code">VkPhysicalDeviceLimits</code>::<em class="parameter"><code>nonCoherentAtomSize</code></em>
</li><li class="listitem">
If <em class="parameter"><code>size</code></em> is not equal to <code class="code">VK_WHOLE_SIZE</code>, <em class="parameter"><code>size</code></em> <span class="normative">must</span> be a
    multiple of <code class="code">VkPhysicalDeviceLimits</code>::<em class="parameter"><code>nonCoherentAtomSize</code></em>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>sType</code></em> <span class="normative">must</span> be <code class="code">VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE</code>
</li><li class="listitem">
<em class="parameter"><code>pNext</code></em> <span class="normative">must</span> be <code class="literal">NULL</code>
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> be a valid <code class="code">VkDeviceMemory</code> handle
</li></ul></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: editing-note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">editing-note</th></tr><tr><td align="left" valign="top"><p>TODO (Tobias) - There’s a circular section reference between this next
section and the <a class="link" href="ch06s01.html#synchronization-fences-devicewrites">synchronization section</a>.
The information is all covered by both places, but it seems a bit weird to
have them reference each other.
Not sure how to resolve it.</p></td></tr></table></div><p>Host-visible memory types that advertise the
<code class="code">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</code> property still require
<a class="link" href="ch06s05.html" title="6.5. Pipeline Barriers">memory barriers</a> between host and
device in order to be coherent, but do not require additional cache
management operations to achieve coherency.
For host writes to be seen by subsequent command buffer operations, a
pipeline barrier from a source of <code class="code">VK_ACCESS_HOST_WRITE_BIT</code> and
<code class="code">VK_PIPELINE_STAGE_HOST_BIT</code> to a destination of the relevant device
pipeline stages and access types <span class="normative">must</span> be performed.
Note that such a barrier is performed
<a class="link" href="ch06s06.html" title="6.6. Host Write Ordering Guarantees">implicitly</a> upon each
command buffer submission, so an explicit barrier is only rarely needed
(e.g. if a command buffer waits upon an event signaled by the host, where
the host wrote some data after submission).
For device writes to be seen by subsequent host reads, a pipeline barrier is
<span class="normative">required</span> to <a class="link" href="ch06s01.html#synchronization-fences-devicewrites">make the writes visible</a>.</p><p>To unmap a memory object once host access to it is no longer needed by the
application, call:</p><p><a id="vkUnmapMemory"></a><strong> </strong>
</p><pre class="programlisting">void vkUnmapMemory(
    VkDevice                                    device,
    VkDeviceMemory                              memory);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> is the logical device that owns the memory.
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> is the memory object to be unmapped.
</li></ul></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> currently be mapped
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> <span class="normative">must</span> be a valid <code class="code">VkDevice</code> handle
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> be a valid <code class="code">VkDeviceMemory</code> handle
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> have been created, allocated, or retrieved from <em class="parameter"><code>device</code></em>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Host Synchronization</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Host access to <em class="parameter"><code>memory</code></em> <span class="normative">must</span> be externally synchronized
</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="memory-device-lazy_allocation"></a>10.2.2. Lazily Allocated Memory</h3></div></div></div><p>If the memory object is allocated from a heap with the
<code class="code">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code> bit set, that object’s backing
memory <span class="normative">may</span> be provided by the implementation lazily.
The actual committed size of the memory <span class="normative">may</span> initially be as small as zero
(or as large as the requested size), and monotonically increases as
additional memory is needed.</p><p>A memory type with this flag set is only allowed to be bound to a
<code class="code">VkImage</code> whose usage flags include
<code class="code">VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT</code>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Using lazily allocated memory objects for framebuffer attachments that are
not needed once a render pass instance has completed <span class="normative">may</span> allow some
implementations to never allocate memory for such attachments.</p></td></tr></table></div><p>To determine the amount of lazily-allocated memory that is currently
committed for a memory object, call:</p><p><a id="vkGetDeviceMemoryCommitment"></a><strong> </strong>
</p><pre class="programlisting">void vkGetDeviceMemoryCommitment(
    VkDevice                                    device,
    VkDeviceMemory                              memory,
    VkDeviceSize*                               pCommittedMemoryInBytes);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> is the logical device that owns the memory.
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> is the memory object being queried.
</li><li class="listitem">
<em class="parameter"><code>pCommittedMemoryInBytes</code></em> is a pointer to a <code class="code">VkDeviceSize</code>
    value in which the number of bytes currently committed is returned, on
    success.
</li></ul></div><p>The implementation <span class="normative">may</span> update the commitment at any time, and the value
returned by this query <span class="normative">may</span> be out of date.</p><p>The implementation guarantees to allocate any committed memory from the
heapIndex indicated by the memory type that the memory object was created
with.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> have been created with a memory type that reports
    <code class="code">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</code>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>device</code></em> <span class="normative">must</span> be a valid <code class="code">VkDevice</code> handle
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> be a valid <code class="code">VkDeviceMemory</code> handle
</li><li class="listitem">
<em class="parameter"><code>pCommittedMemoryInBytes</code></em> <span class="normative">must</span> be a pointer to a <code class="code">VkDeviceSize</code> value
</li><li class="listitem">
<em class="parameter"><code>memory</code></em> <span class="normative">must</span> have been created, allocated, or retrieved from <em class="parameter"><code>device</code></em>
</li></ul></div></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch10s01.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"><a accesskey="u" href="ch10.html"><img src="images/icons/up.png" alt="Up" /></a></td><td width="40%" align="right"> <a accesskey="n" href="ch11.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>