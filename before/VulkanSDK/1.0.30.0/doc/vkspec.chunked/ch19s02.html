<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>19.2. Programmable Primitive Shading</title><link rel="stylesheet" type="text/css" href="config/vkspec-xhtml.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Vulkan 1.0.30 - A Specification (with WSI extensions)" /><link rel="up" href="ch19.html" title="Chapter 19. Drawing Commands" /><link rel="prev" href="ch19s01.html" title="19.1. Primitive Topologies" /><link rel="next" href="ch20.html" title="Chapter 20. Fixed-Function Vertex Processing" /><script xmlns="" type="text/x-mathjax-config">
        MathJax.Hub.Config({
            MathML: { extensions: ["content-mathml.js"] },
            tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] }
        });
    </script><script xmlns="" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch19s01.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch20.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_programmable_primitive_shading"></a>19.2. Programmable Primitive Shading</h2></div></div></div><p>Once primitives are assembled, they proceed to the vertex shading stage of
the pipeline.
If the draw includes multiple instances, then the set of primitives is sent
to the vertex shading stage multiple times, once for each instance.</p><p>It is undefined whether vertex shading occurs on vertices that are discarded
as part of incomplete primitives, but if it does occur then it operates as
if they were vertices in complete primitives and such invocations <span class="normative">can</span> have
side effects.</p><p>Vertex shading receives two per-vertex inputs from the primitive assembly
stage - the <span class="strong"><strong><code class="code">vertexIndex</code></strong></span> and the <span class="strong"><strong><code class="code">instanceIndex</code></strong></span>.
How these values are generated is defined below, with each command.</p><p>Drawing commands fall roughly into two categories:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">
Non-indexed drawing commands present a sequential <span class="strong"><strong><code class="code">vertexIndex</code></strong></span> to
    the vertex shader.
    The sequential index is generated automatically by the device (see
    <a class="link" href="ch20.html" title="Chapter 20. Fixed-Function Vertex Processing">Fixed-Function Vertex Processing</a> for details on both
    specifying the vertex attributes indexed by <span class="strong"><strong><code class="code">vertexIndex</code></strong></span>, as well as
    binding vertex buffers containing those attributes to a command buffer).
    These commands are:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
<code class="code"><a class="link" href="ch19s02.html#vkCmdDraw">vkCmdDraw</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndirect">vkCmdDrawIndirect</a></code>
</li></ul></div></li><li class="listitem"><p class="simpara">
Indexed drawing commands read index values from an <span class="emphasis"><em>index buffer</em></span> and
    use this to compute the <span class="strong"><strong><code class="code">vertexIndex</code></strong></span> value for the vertex shader.
    These commands are:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem">
<code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndexed">vkCmdDrawIndexed</a></code>
</li><li class="listitem">
<code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndexedIndirect">vkCmdDrawIndexedIndirect</a></code>
</li></ul></div></li></ul></div><p>To bind an index buffer to a command buffer, call:</p><p><a id="vkCmdBindIndexBuffer"></a><strong> </strong>
</p><pre class="programlisting">void vkCmdBindIndexBuffer(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> is the command buffer into which the command is
    recorded.
</li><li class="listitem">
<em class="parameter"><code>buffer</code></em> is the buffer being bound.
</li><li class="listitem">
<em class="parameter"><code>offset</code></em> is the starting offset in bytes within <em class="parameter"><code>buffer</code></em> used in
    index buffer address calculations.
</li><li class="listitem"><p class="simpara">
<em class="parameter"><code>indexType</code></em> selects whether indices are treated as 16 bits or 32
    bits.
    Possible values include:
</p><p><a id="VkIndexType"></a><strong> </strong>
</p><pre class="programlisting">typedef enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
} VkIndexType;</pre><p>
</p></li></ul></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>offset</code></em> <span class="normative">must</span> be less than the size of <em class="parameter"><code>buffer</code></em>
</li><li class="listitem">
The sum of <em class="parameter"><code>offset</code></em> and the address of the range of
    <code class="code">VkDeviceMemory</code> object that is backing <em class="parameter"><code>buffer</code></em>, <span class="normative">must</span> be a
    multiple of the type indicated by <em class="parameter"><code>indexType</code></em>
</li><li class="listitem">
<em class="parameter"><code>buffer</code></em> <span class="normative">must</span> have been created with the
    <code class="code">VK_BUFFER_USAGE_INDEX_BUFFER_BIT</code> flag
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be a valid <code class="code">VkCommandBuffer</code> handle
</li><li class="listitem">
<em class="parameter"><code>buffer</code></em> <span class="normative">must</span> be a valid <code class="code">VkBuffer</code> handle
</li><li class="listitem">
<em class="parameter"><code>indexType</code></em> <span class="normative">must</span> be a valid <code class="code"><a class="link" href="ch19s02.html#VkIndexType">VkIndexType</a></code> value
</li><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be in the recording state
</li><li class="listitem">
The <code class="code">VkCommandPool</code> that <em class="parameter"><code>commandBuffer</code></em> was allocated from <span class="normative">must</span> support graphics operations
</li><li class="listitem">
Both of <em class="parameter"><code>buffer</code></em>, and <em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> have been created, allocated, or retrieved from the same <code class="code">VkDevice</code>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Host Synchronization</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Host access to <em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be externally synchronized
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Command Properties</strong></p></div></div></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; " width="100%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Command Buffer Levels</th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Render Pass Scope</th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top">Supported Queue Types</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Primary
Secondary</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Both</p></td><td style="" align="left" valign="top"><p>GRAPHICS</p></td></tr></tbody></table></div></div><p>The parameters for each drawing command are specified directly in the
command or read from buffer memory, depending on the command.
Drawing commands that source their parameters from buffer memory are known
as <span class="emphasis"><em>indirect</em></span> drawing commands.</p><p>All drawing commands interact with the
<a class="link" href="ch31s01.html#features-features-robustBufferAccess">Robust Buffer Access</a> feature.</p><p><a id="drawing-primitive-assembly-apiorder"></a>Primitives assembled by draw commands are considered to have an
<a class="link" href="ch02s02.html#fundamentals-queueoperation-apiorder">API order</a>, which defines the order
their fragments affect the framebuffer.
When a draw command includes multiple instances, the lower numbered
instances are earlier in API order.
For non-indexed draws, primitives with lower numbered <span class="strong"><strong><code class="code">vertexIndex</code></strong></span>
values are earlier in API order.
For indexed draws, primitives assembled from lower index buffer addresses
are earlier in API order.</p><p>To record a non-indexed draw, call:</p><p><a id="vkCmdDraw"></a><strong> </strong>
</p><pre class="programlisting">void vkCmdDraw(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> is the command buffer into which the command is
    recorded.
</li><li class="listitem">
<em class="parameter"><code>vertexCount</code></em> is the number of vertices to draw.
</li><li class="listitem">
<em class="parameter"><code>instanceCount</code></em> is the number of instances to draw.
</li><li class="listitem">
<em class="parameter"><code>firstVertex</code></em> is the index of the first vertex to draw.
</li><li class="listitem">
<em class="parameter"><code>firstInstance</code></em> is the instance ID of the first instance to draw.
</li></ul></div><p>When the command is executed, primitives are assembled using the current
primitive topology and <em class="parameter"><code>vertexCount</code></em> consecutive vertex indices with the
first <span class="strong"><strong><code class="code">vertexIndex</code></strong></span> value equal to <em class="parameter"><code>firstVertex</code></em>.
The primitives are drawn <em class="parameter"><code>instanceCount</code></em> times with <span class="strong"><strong><code class="code">instanceIndex</code></strong></span>
starting with <em class="parameter"><code>firstInstance</code></em> and increasing sequentially for each
instance.
The assembled primitives execute the currently bound graphics pipeline.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
For each set <span class="emphasis"><em>n</em></span> that is statically used by the <code class="code">VkPipeline</code>
    currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a descriptor
    set <span class="normative">must</span> have been bound to <span class="emphasis"><em>n</em></span> at
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code class="code">VkPipelineLayout</code>
    that is compatible for set <span class="emphasis"><em>n</em></span>, with the <code class="code">VkPipelineLayout</code> used to
    create the current <code class="code">VkPipeline</code>, as described in
    <a class="xref" href="ch13s02.html#descriptorsets-compatibility" title="Pipeline Layout Compatibility">the section called “Pipeline Layout Compatibility”</a>
</li><li class="listitem">
For each push constant that is statically used by the <code class="code">VkPipeline</code>
    currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a push
    constant value <span class="normative">must</span> have been set for
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code class="code">VkPipelineLayout</code>
    that is compatible for push constants, with the <code class="code">VkPipelineLayout</code>
    used to create the current <code class="code">VkPipeline</code>, as described in
    <a class="xref" href="ch13s02.html#descriptorsets-compatibility" title="Pipeline Layout Compatibility">the section called “Pipeline Layout Compatibility”</a>
</li><li class="listitem">
Descriptors in each bound descriptor set, specified via
    <span class="strong"><strong><code class="code">vkCmdBindDescriptorSets</code></strong></span>, <span class="normative">must</span> be valid if they are statically
    used by the currently bound <code class="code">VkPipeline</code> object, specified via
    <span class="strong"><strong><code class="code">vkCmdBindPipeline</code></strong></span>
</li><li class="listitem">
All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point’s interface <span class="normative">must</span> have valid buffers
    bound
</li><li class="listitem">
For a given vertex buffer binding, any attribute data fetched <span class="normative">must</span> be
    entirely contained within the corresponding vertex buffer binding, as
    described in <a class="xref" href="ch20s02.html" title="20.2. Vertex Input Description">Section 20.2, “Vertex Input Description”</a>
</li><li class="listitem">
A valid graphics pipeline <span class="normative">must</span> be bound to the current command buffer
    with <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>
</li><li class="listitem">
If the <code class="code">VkPipeline</code> object currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> requires any dynamic state, that
    state <span class="normative">must</span> have been set on the current command buffer
</li><li class="listitem">
Every input attachment used by the current subpass <span class="normative">must</span> be bound to the
    pipeline via a descriptor set
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used to sample from any <code class="code">VkImage</code> with a
    <code class="code">VkImageView</code> of the type <code class="code">VK_IMAGE_VIEW_TYPE_3D</code>,
    <code class="code">VK_IMAGE_VIEW_TYPE_CUBE</code>, <code class="code">VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>,
    <code class="code">VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or
    <code class="code">VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used with any of the SPIR-V <code class="literal">OpImageSample*</code> or
    <code class="literal">OpImageSparseSample*</code> instructions with <span class="strong"><strong><code class="code">ImplicitLod</code></strong></span>, <span class="strong"><strong><code class="code">Dref</code></strong></span> or
    <span class="strong"><strong><code class="code">Proj</code></strong></span> in their name, in any shader stage
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used with any of the SPIR-V <code class="literal">OpImageSample*</code> or
    <code class="literal">OpImageSparseSample*</code> instructions that includes a LOD bias or any
    offset values, in any shader stage
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-robustBufferAccess">robust buffer access</a>
    feature is not enabled, and any shader stage in the <code class="code">VkPipeline</code>
    object currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses
    a uniform buffer, it <span class="normative">must</span> not access values outside of the range of
    that buffer specified in the currently bound descriptor set
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-robustBufferAccess">robust buffer access</a>
    feature is not enabled, and any shader stage in the <code class="code">VkPipeline</code>
    object currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses
    a storage buffer, it <span class="normative">must</span> not access values outside of the range of
    that buffer specified in the currently bound descriptor set
</li><li class="listitem">
Any <code class="code">VkImageView</code> being sampled with <code class="code">VK_FILTER_LINEAR</code> as a
    result of this command <span class="normative">must</span> be of a format which supports linear
    filtering, as specified by the
    <code class="code">VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in
    <code class="code">VkFormatProperties</code>::<em class="parameter"><code>linearTilingFeatures</code></em> (for a linear
    image) or <code class="code">VkFormatProperties</code>::<em class="parameter"><code>optimalTilingFeatures</code></em>(for an
    optimally tiled image) returned by
    <span class="strong"><strong><code class="code">vkGetPhysicalDeviceFormatProperties</code></strong></span>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be a valid <code class="code">VkCommandBuffer</code> handle
</li><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be in the recording state
</li><li class="listitem">
The <code class="code">VkCommandPool</code> that <em class="parameter"><code>commandBuffer</code></em> was allocated from <span class="normative">must</span> support graphics operations
</li><li class="listitem">
This command <span class="normative">must</span> only be called inside of a render pass instance
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Host Synchronization</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Host access to <em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be externally synchronized
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Command Properties</strong></p></div></div></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; " width="100%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Command Buffer Levels</th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Render Pass Scope</th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top">Supported Queue Types</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Primary
Secondary</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Inside</p></td><td style="" align="left" valign="top"><p>GRAPHICS</p></td></tr></tbody></table></div></div><p>To record an indexed draw, call:</p><p><a id="vkCmdDrawIndexed"></a><strong> </strong>
</p><pre class="programlisting">void vkCmdDrawIndexed(
    VkCommandBuffer                             commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> is the command buffer into which the command is
    recorded.
</li><li class="listitem">
<em class="parameter"><code>indexCount</code></em> is the number of vertices to draw.
</li><li class="listitem">
<em class="parameter"><code>instanceCount</code></em> is the number of instances to draw.
</li><li class="listitem">
<em class="parameter"><code>firstIndex</code></em> is the base index within the index buffer.
</li><li class="listitem">
<em class="parameter"><code>vertexOffset</code></em> is the value added to the vertex index before
    indexing into the vertex buffer.
</li><li class="listitem">
<em class="parameter"><code>firstInstance</code></em> is the instance ID of the first instance to draw.
</li></ul></div><p>When the command is executed, primitives are assembled using the current
primitive topology and <em class="parameter"><code>indexCount</code></em> vertices whose indices are retrieved
from the index buffer.
The index buffer is treated as an array of tightly packed unsigned integers
of size defined by the <code class="code"><a class="link" href="ch19s02.html#vkCmdBindIndexBuffer">vkCmdBindIndexBuffer</a></code>::<em class="parameter"><code>indexType</code></em> parameter
with which the buffer was bound.</p><p>The first vertex index is at an offset of <em class="parameter"><code>firstIndex</code></em> * <span class="strong"><strong><code class="code">indexSize</code></strong></span>
+ <em class="parameter"><code>offset</code></em> within the currently bound index buffer, where <em class="parameter"><code>offset</code></em>
is the offset specified by <span class="strong"><strong><code class="code">vkCmdBindIndexBuffer</code></strong></span> and <span class="strong"><strong><code class="code">indexSize</code></strong></span> is
the byte size of the type specified by <em class="parameter"><code>indexType</code></em>.
Subsequent index values are retrieved from consecutive locations in the
index buffer.
Indices are first compared to the primitive restart value, then zero
extended to 32 bits (if the <span class="strong"><strong><code class="code">indexType</code></strong></span> is <code class="code">VK_INDEX_TYPE_UINT16</code>)
and have <em class="parameter"><code>vertexOffset</code></em> added to them, before being supplied as the
<span class="strong"><strong><code class="code">vertexIndex</code></strong></span> value.</p><p>The primitives are drawn <em class="parameter"><code>instanceCount</code></em> times with <span class="strong"><strong><code class="code">instanceIndex</code></strong></span>
starting with <em class="parameter"><code>firstInstance</code></em> and increasing sequentially for each
instance.
The assembled primitives execute the currently bound graphics pipeline.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
For each set <span class="emphasis"><em>n</em></span> that is statically used by the <code class="code">VkPipeline</code>
    currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a descriptor
    set <span class="normative">must</span> have been bound to <span class="emphasis"><em>n</em></span> at
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code class="code">VkPipelineLayout</code>
    that is compatible for set <span class="emphasis"><em>n</em></span>, with the <code class="code">VkPipelineLayout</code> used to
    create the current <code class="code">VkPipeline</code>, as described in
    <a class="xref" href="ch13s02.html#descriptorsets-compatibility" title="Pipeline Layout Compatibility">the section called “Pipeline Layout Compatibility”</a>
</li><li class="listitem">
For each push constant that is statically used by the <code class="code">VkPipeline</code>
    currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a push
    constant value <span class="normative">must</span> have been set for
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code class="code">VkPipelineLayout</code>
    that is compatible for push constants, with the <code class="code">VkPipelineLayout</code>
    used to create the current <code class="code">VkPipeline</code>, as described in
    <a class="xref" href="ch13s02.html#descriptorsets-compatibility" title="Pipeline Layout Compatibility">the section called “Pipeline Layout Compatibility”</a>
</li><li class="listitem">
Descriptors in each bound descriptor set, specified via
    <span class="strong"><strong><code class="code">vkCmdBindDescriptorSets</code></strong></span>, <span class="normative">must</span> be valid if they are statically
    used by the currently bound <code class="code">VkPipeline</code> object, specified via
    <span class="strong"><strong><code class="code">vkCmdBindPipeline</code></strong></span>
</li><li class="listitem">
All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point’s interface <span class="normative">must</span> have valid buffers
    bound
</li><li class="listitem">
For a given vertex buffer binding, any attribute data fetched <span class="normative">must</span> be
    entirely contained within the corresponding vertex buffer binding, as
    described in <a class="xref" href="ch20s02.html" title="20.2. Vertex Input Description">Section 20.2, “Vertex Input Description”</a>
</li><li class="listitem">
A valid graphics pipeline <span class="normative">must</span> be bound to the current command buffer
    with <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>
</li><li class="listitem">
If the <code class="code">VkPipeline</code> object currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> requires any dynamic state, that
    state <span class="normative">must</span> have been set on the current command buffer
</li><li class="listitem">
(<em class="parameter"><code>indexSize</code></em> * (<em class="parameter"><code>firstIndex</code></em> + <em class="parameter"><code>indexCount</code></em>) + <em class="parameter"><code>offset</code></em>)
    <span class="normative">must</span> be less than or equal to the size of the currently bound index
    buffer, with indexSize being based on the type specified by
    <em class="parameter"><code>indexType</code></em>, where the index buffer, <em class="parameter"><code>indexType</code></em>, and
    <em class="parameter"><code>offset</code></em> are specified via <span class="strong"><strong><code class="code">vkCmdBindIndexBuffer</code></strong></span>
</li><li class="listitem">
Every input attachment used by the current subpass <span class="normative">must</span> be bound to the
    pipeline via a descriptor set
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used to sample from any <code class="code">VkImage</code> with a
    <code class="code">VkImageView</code> of the type <code class="code">VK_IMAGE_VIEW_TYPE_3D</code>,
    <code class="code">VK_IMAGE_VIEW_TYPE_CUBE</code>, <code class="code">VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>,
    <code class="code">VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or
    <code class="code">VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used with any of the SPIR-V <code class="literal">OpImageSample*</code> or
    <code class="literal">OpImageSparseSample*</code> instructions with <span class="strong"><strong><code class="code">ImplicitLod</code></strong></span>, <span class="strong"><strong><code class="code">Dref</code></strong></span> or
    <span class="strong"><strong><code class="code">Proj</code></strong></span> in their name, in any shader stage
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used with any of the SPIR-V <code class="literal">OpImageSample*</code> or
    <code class="literal">OpImageSparseSample*</code> instructions that includes a LOD bias or any
    offset values, in any shader stage
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-robustBufferAccess">robust buffer access</a>
    feature is not enabled, and any shader stage in the <code class="code">VkPipeline</code>
    object currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses
    a uniform buffer, it <span class="normative">must</span> not access values outside of the range of
    that buffer specified in the currently bound descriptor set
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-robustBufferAccess">robust buffer access</a>
    feature is not enabled, and any shader stage in the <code class="code">VkPipeline</code>
    object currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses
    a storage buffer, it <span class="normative">must</span> not access values outside of the range of
    that buffer specified in the currently bound descriptor set
</li><li class="listitem">
Any <code class="code">VkImageView</code> being sampled with <code class="code">VK_FILTER_LINEAR</code> as a
    result of this command <span class="normative">must</span> be of a format which supports linear
    filtering, as specified by the
    <code class="code">VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in
    <code class="code">VkFormatProperties</code>::<em class="parameter"><code>linearTilingFeatures</code></em> (for a linear
    image) or <code class="code">VkFormatProperties</code>::<em class="parameter"><code>optimalTilingFeatures</code></em>(for an
    optimally tiled image) returned by
    <span class="strong"><strong><code class="code">vkGetPhysicalDeviceFormatProperties</code></strong></span>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be a valid <code class="code">VkCommandBuffer</code> handle
</li><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be in the recording state
</li><li class="listitem">
The <code class="code">VkCommandPool</code> that <em class="parameter"><code>commandBuffer</code></em> was allocated from <span class="normative">must</span> support graphics operations
</li><li class="listitem">
This command <span class="normative">must</span> only be called inside of a render pass instance
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Host Synchronization</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Host access to <em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be externally synchronized
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Command Properties</strong></p></div></div></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; " width="100%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Command Buffer Levels</th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Render Pass Scope</th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top">Supported Queue Types</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Primary
Secondary</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Inside</p></td><td style="" align="left" valign="top"><p>GRAPHICS</p></td></tr></tbody></table></div></div><p>To record a non-indexed indirect draw, call:</p><p><a id="vkCmdDrawIndirect"></a><strong> </strong>
</p><pre class="programlisting">void vkCmdDrawIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> is the command buffer into which the command is
    recorded.
</li><li class="listitem">
<em class="parameter"><code>buffer</code></em> is the buffer containing draw parameters.
</li><li class="listitem">
<em class="parameter"><code>offset</code></em> is the byte offset into <em class="parameter"><code>buffer</code></em> where parameters
    begin.
</li><li class="listitem">
<em class="parameter"><code>drawCount</code></em> is the number of draws to execute, and <span class="normative">can</span> be zero.
</li><li class="listitem">
<em class="parameter"><code>stride</code></em> is the byte stride between successive sets of draw
    parameters.
</li></ul></div><p><span class="strong"><strong><code class="code">vkCmdDrawIndirect</code></strong></span> behaves similarly to <code class="code"><a class="link" href="ch19s02.html#vkCmdDraw">vkCmdDraw</a></code> except that the
parameters are read by the device from a buffer during execution.
<em class="parameter"><code>drawCount</code></em> draws are executed by the command, with parameters taken
from <em class="parameter"><code>buffer</code></em> starting at <em class="parameter"><code>offset</code></em> and increasing by <em class="parameter"><code>stride</code></em>
bytes for each successive draw.
The parameters of each draw are encoded in an array of
<code class="code"><a class="link" href="ch19s02.html#VkDrawIndirectCommand">VkDrawIndirectCommand</a></code> structures.
If <em class="parameter"><code>drawCount</code></em> is less than or equal to one, <em class="parameter"><code>stride</code></em> is ignored.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>offset</code></em> <span class="normative">must</span> be a multiple of <code class="literal">4</code>
</li><li class="listitem">
If <em class="parameter"><code>drawCount</code></em> is greater than <code class="literal">1</code>, <em class="parameter"><code>stride</code></em> <span class="normative">must</span> be a multiple
    of <code class="literal">4</code> and <span class="normative">must</span> be greater than or equal to
    sizeof(<code class="code">VkDrawIndirectCommand</code>)
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-multiDrawIndirect">multi-draw indirect</a>
    feature is not enabled, <em class="parameter"><code>drawCount</code></em> <span class="normative">must</span> be <code class="literal">0</code> or <code class="literal">1</code>
</li><li class="listitem">
If the
    <a class="link" href="ch31s01.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a>
    feature is not enabled, all the <em class="parameter"><code>firstInstance</code></em> members of the
    <code class="code">VkDrawIndirectCommand</code> structures accessed by this command <span class="normative">must</span> be
    <span class="strong"><strong><code class="code">0</code></strong></span>
</li><li class="listitem">
For each set <span class="emphasis"><em>n</em></span> that is statically used by the <code class="code">VkPipeline</code>
    currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a descriptor
    set <span class="normative">must</span> have been bound to <span class="emphasis"><em>n</em></span> at
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code class="code">VkPipelineLayout</code>
    that is compatible for set <span class="emphasis"><em>n</em></span>, with the <code class="code">VkPipelineLayout</code> used to
    create the current <code class="code">VkPipeline</code>, as described in
    <a class="xref" href="ch13s02.html#descriptorsets-compatibility" title="Pipeline Layout Compatibility">the section called “Pipeline Layout Compatibility”</a>
</li><li class="listitem">
For each push constant that is statically used by the <code class="code">VkPipeline</code>
    currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a push
    constant value <span class="normative">must</span> have been set for
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code class="code">VkPipelineLayout</code>
    that is compatible for push constants, with the <code class="code">VkPipelineLayout</code>
    used to create the current <code class="code">VkPipeline</code>, as described in
    <a class="xref" href="ch13s02.html#descriptorsets-compatibility" title="Pipeline Layout Compatibility">the section called “Pipeline Layout Compatibility”</a>
</li><li class="listitem">
Descriptors in each bound descriptor set, specified via
    <span class="strong"><strong><code class="code">vkCmdBindDescriptorSets</code></strong></span>, <span class="normative">must</span> be valid if they are statically
    used by the currently bound <code class="code">VkPipeline</code> object, specified via
    <span class="strong"><strong><code class="code">vkCmdBindPipeline</code></strong></span>
</li><li class="listitem">
All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point’s interface <span class="normative">must</span> have valid buffers
    bound
</li><li class="listitem">
A valid graphics pipeline <span class="normative">must</span> be bound to the current command buffer
    with <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>
</li><li class="listitem">
If the <code class="code">VkPipeline</code> object currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> requires any dynamic state, that
    state <span class="normative">must</span> have been set on the current command buffer
</li><li class="listitem">
If <em class="parameter"><code>drawCount</code></em> is equal to <code class="literal">1</code>, <span class="eq">(<em class="parameter"><code>offset</code></em> +
    sizeof(<code class="code"><a class="link" href="ch19s02.html#VkDrawIndirectCommand">VkDrawIndirectCommand</a></code>))</span> <span class="normative">must</span> be less than or equal to the
    size of <em class="parameter"><code>buffer</code></em>
</li><li class="listitem">
If <em class="parameter"><code>drawCount</code></em> is greater than <code class="literal">1</code>, <span class="eq">(<em class="parameter"><code>stride</code></em> ×
    (<em class="parameter"><code>drawCount</code></em> - 1) + <em class="parameter"><code>offset</code></em> +
    sizeof(<code class="code"><a class="link" href="ch19s02.html#VkDrawIndirectCommand">VkDrawIndirectCommand</a></code>))</span> <span class="normative">must</span> be less than or equal to the
    size of <em class="parameter"><code>buffer</code></em>
</li><li class="listitem">
<em class="parameter"><code>drawCount</code></em> <span class="normative">must</span> be less than or equal to
    <code class="code">VkPhysicalDeviceLimits</code>::<em class="parameter"><code>maxDrawIndirectCount</code></em>
</li><li class="listitem">
Every input attachment used by the current subpass <span class="normative">must</span> be bound to the
    pipeline via a descriptor set
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used to sample from any <code class="code">VkImage</code> with a
    <code class="code">VkImageView</code> of the type <code class="code">VK_IMAGE_VIEW_TYPE_3D</code>,
    <code class="code">VK_IMAGE_VIEW_TYPE_CUBE</code>, <code class="code">VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>,
    <code class="code">VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or
    <code class="code">VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used with any of the SPIR-V <code class="literal">OpImageSample*</code> or
    <code class="literal">OpImageSparseSample*</code> instructions with <span class="strong"><strong><code class="code">ImplicitLod</code></strong></span>, <span class="strong"><strong><code class="code">Dref</code></strong></span> or
    <span class="strong"><strong><code class="code">Proj</code></strong></span> in their name, in any shader stage
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used with any of the SPIR-V <code class="literal">OpImageSample*</code> or
    <code class="literal">OpImageSparseSample*</code> instructions that includes a LOD bias or any
    offset values, in any shader stage
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-robustBufferAccess">robust buffer access</a>
    feature is not enabled, and any shader stage in the <code class="code">VkPipeline</code>
    object currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses
    a uniform buffer, it <span class="normative">must</span> not access values outside of the range of
    that buffer specified in the currently bound descriptor set
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-robustBufferAccess">robust buffer access</a>
    feature is not enabled, and any shader stage in the <code class="code">VkPipeline</code>
    object currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses
    a storage buffer, it <span class="normative">must</span> not access values outside of the range of
    that buffer specified in the currently bound descriptor set
</li><li class="listitem">
Any <code class="code">VkImageView</code> being sampled with <code class="code">VK_FILTER_LINEAR</code> as a
    result of this command <span class="normative">must</span> be of a format which supports linear
    filtering, as specified by the
    <code class="code">VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in
    <code class="code">VkFormatProperties</code>::<em class="parameter"><code>linearTilingFeatures</code></em> (for a linear
    image) or <code class="code">VkFormatProperties</code>::<em class="parameter"><code>optimalTilingFeatures</code></em>(for an
    optimally tiled image) returned by
    <span class="strong"><strong><code class="code">vkGetPhysicalDeviceFormatProperties</code></strong></span>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be a valid <code class="code">VkCommandBuffer</code> handle
</li><li class="listitem">
<em class="parameter"><code>buffer</code></em> <span class="normative">must</span> be a valid <code class="code">VkBuffer</code> handle
</li><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be in the recording state
</li><li class="listitem">
The <code class="code">VkCommandPool</code> that <em class="parameter"><code>commandBuffer</code></em> was allocated from <span class="normative">must</span> support graphics operations
</li><li class="listitem">
This command <span class="normative">must</span> only be called inside of a render pass instance
</li><li class="listitem">
Both of <em class="parameter"><code>buffer</code></em>, and <em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> have been created, allocated, or retrieved from the same <code class="code">VkDevice</code>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Host Synchronization</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Host access to <em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be externally synchronized
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Command Properties</strong></p></div></div></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; " width="100%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Command Buffer Levels</th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Render Pass Scope</th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top">Supported Queue Types</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Primary
Secondary</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Inside</p></td><td style="" align="left" valign="top"><p>GRAPHICS</p></td></tr></tbody></table></div></div><p>The <code class="code">VkDrawIndirectCommand</code> structure is defined as:</p><p><a id="VkDrawIndirectCommand"></a><strong> </strong>
</p><pre class="programlisting">typedef struct VkDrawIndirectCommand {
    uint32_t    vertexCount;
    uint32_t    instanceCount;
    uint32_t    firstVertex;
    uint32_t    firstInstance;
} VkDrawIndirectCommand;</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>vertexCount</code></em> is the number of vertices to draw.
</li><li class="listitem">
<em class="parameter"><code>instanceCount</code></em> is the number of instances to draw.
</li><li class="listitem">
<em class="parameter"><code>firstVertex</code></em> is the index of the first vertex to draw.
</li><li class="listitem">
<em class="parameter"><code>firstInstance</code></em> is the instance ID of the first instance to draw.
</li></ul></div><p>The members of <code class="code">VkDrawIndirectCommand</code> have the same meaning as the
similarly named parameters of <code class="code"><a class="link" href="ch19s02.html#vkCmdDraw">vkCmdDraw</a></code>.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
For a given vertex buffer binding, any attribute data fetched <span class="normative">must</span> be
    entirely contained within the corresponding vertex buffer binding, as
    described in <a class="xref" href="ch20s02.html" title="20.2. Vertex Input Description">Section 20.2, “Vertex Input Description”</a>
</li><li class="listitem">
If the
    <a class="link" href="ch31s01.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a>
    feature is not enabled, <em class="parameter"><code>firstInstance</code></em> <span class="normative">must</span> be <span class="strong"><strong><code class="code">0</code></strong></span>
</li></ul></div></div><p>To record an indexed indirect draw, call:</p><p><a id="vkCmdDrawIndexedIndirect"></a><strong> </strong>
</p><pre class="programlisting">void vkCmdDrawIndexedIndirect(
    VkCommandBuffer                             commandBuffer,
    VkBuffer                                    buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride);</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> is the command buffer into which the command is
    recorded.
</li><li class="listitem">
<em class="parameter"><code>buffer</code></em> is the buffer containing draw parameters.
</li><li class="listitem">
<em class="parameter"><code>offset</code></em> is the byte offset into <em class="parameter"><code>buffer</code></em> where parameters
    begin.
</li><li class="listitem">
<em class="parameter"><code>drawCount</code></em> is the number of draws to execute, and <span class="normative">can</span> be zero.
</li><li class="listitem">
<em class="parameter"><code>stride</code></em> is the byte stride between successive sets of draw
    parameters.
</li></ul></div><p><span class="strong"><strong><code class="code">vkCmdDrawIndexedIndirect</code></strong></span> behaves similarly to <code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndexed">vkCmdDrawIndexed</a></code>
except that the parameters are read by the device from a buffer during
execution.
<em class="parameter"><code>drawCount</code></em> draws are executed by the command, with parameters taken
from <em class="parameter"><code>buffer</code></em> starting at <em class="parameter"><code>offset</code></em> and increasing by <em class="parameter"><code>stride</code></em>
bytes for each successive draw.
The parameters of each draw are encoded in an array of
<code class="code"><a class="link" href="ch19s02.html#VkDrawIndexedIndirectCommand">VkDrawIndexedIndirectCommand</a></code> structures.
If <em class="parameter"><code>drawCount</code></em> is less than or equal to one, <em class="parameter"><code>stride</code></em> is ignored.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>offset</code></em> <span class="normative">must</span> be a multiple of <code class="literal">4</code>
</li><li class="listitem">
If <em class="parameter"><code>drawCount</code></em> is greater than <code class="literal">1</code>, <em class="parameter"><code>stride</code></em> <span class="normative">must</span> be a multiple
    of <code class="literal">4</code> and <span class="normative">must</span> be greater than or equal to
    sizeof(<code class="code">VkDrawIndexedIndirectCommand</code>)
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-multiDrawIndirect">multi-draw indirect</a>
    feature is not enabled, <em class="parameter"><code>drawCount</code></em> <span class="normative">must</span> be <code class="literal">0</code> or <code class="literal">1</code>
</li><li class="listitem">
If the
    <a class="link" href="ch31s01.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a>
    feature is not enabled, all the <em class="parameter"><code>firstInstance</code></em> members of the
    <code class="code">VkDrawIndexedIndirectCommand</code> structures accessed by this command
    <span class="normative">must</span> be <span class="strong"><strong><code class="code">0</code></strong></span>
</li><li class="listitem">
For each set <span class="emphasis"><em>n</em></span> that is statically used by the <code class="code">VkPipeline</code>
    currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a descriptor
    set <span class="normative">must</span> have been bound to <span class="emphasis"><em>n</em></span> at
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code class="code">VkPipelineLayout</code>
    that is compatible for set <span class="emphasis"><em>n</em></span>, with the <code class="code">VkPipelineLayout</code> used to
    create the current <code class="code">VkPipeline</code>, as described in
    <a class="xref" href="ch13s02.html#descriptorsets-compatibility" title="Pipeline Layout Compatibility">the section called “Pipeline Layout Compatibility”</a>
</li><li class="listitem">
For each push constant that is statically used by the <code class="code">VkPipeline</code>
    currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, a push
    constant value <span class="normative">must</span> have been set for
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>, with a <code class="code">VkPipelineLayout</code>
    that is compatible for push constants, with the <code class="code">VkPipelineLayout</code>
    used to create the current <code class="code">VkPipeline</code>, as described in
    <a class="xref" href="ch13s02.html#descriptorsets-compatibility" title="Pipeline Layout Compatibility">the section called “Pipeline Layout Compatibility”</a>
</li><li class="listitem">
Descriptors in each bound descriptor set, specified via
    <span class="strong"><strong><code class="code">vkCmdBindDescriptorSets</code></strong></span>, <span class="normative">must</span> be valid if they are statically
    used by the currently bound <code class="code">VkPipeline</code> object, specified via
    <span class="strong"><strong><code class="code">vkCmdBindPipeline</code></strong></span>
</li><li class="listitem">
All vertex input bindings accessed via vertex input variables declared
    in the vertex shader entry point’s interface <span class="normative">must</span> have valid buffers
    bound
</li><li class="listitem">
A valid graphics pipeline <span class="normative">must</span> be bound to the current command buffer
    with <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code>
</li><li class="listitem">
If the <code class="code">VkPipeline</code> object currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> requires any dynamic state, that
    state <span class="normative">must</span> have been set on the current command buffer
</li><li class="listitem">
If <em class="parameter"><code>drawCount</code></em> is equal to <code class="literal">1</code>, <span class="eq">(<em class="parameter"><code>offset</code></em> +
    sizeof(<code class="code">VkDrawIndexedIndirectCommand</code>))</span> <span class="normative">must</span> be less than or equal
    to the size of <em class="parameter"><code>buffer</code></em>
</li><li class="listitem">
If <em class="parameter"><code>drawCount</code></em> is greater than <code class="literal">1</code>, <span class="eq">(<em class="parameter"><code>stride</code></em> ×
    (<em class="parameter"><code>drawCount</code></em> - 1) + <em class="parameter"><code>offset</code></em> +
    sizeof(<code class="code">VkDrawIndexedIndirectCommand</code>))</span> <span class="normative">must</span> be less than or equal
    to the size of <em class="parameter"><code>buffer</code></em>
</li><li class="listitem">
<em class="parameter"><code>drawCount</code></em> <span class="normative">must</span> be less than or equal to
    <code class="code">VkPhysicalDeviceLimits</code>::<em class="parameter"><code>maxDrawIndirectCount</code></em>
</li><li class="listitem">
Every input attachment used by the current subpass <span class="normative">must</span> be bound to the
    pipeline via a descriptor set
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used to sample from any <code class="code">VkImage</code> with a
    <code class="code">VkImageView</code> of the type <code class="code">VK_IMAGE_VIEW_TYPE_3D</code>,
    <code class="code">VK_IMAGE_VIEW_TYPE_CUBE</code>, <code class="code">VK_IMAGE_VIEW_TYPE_1D_ARRAY</code>,
    <code class="code">VK_IMAGE_VIEW_TYPE_2D_ARRAY</code> or
    <code class="code">VK_IMAGE_VIEW_TYPE_CUBE_ARRAY</code>, in any shader stage
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used with any of the SPIR-V <code class="literal">OpImageSample*</code> or
    <code class="literal">OpImageSparseSample*</code> instructions with <span class="strong"><strong><code class="code">ImplicitLod</code></strong></span>, <span class="strong"><strong><code class="code">Dref</code></strong></span> or
    <span class="strong"><strong><code class="code">Proj</code></strong></span> in their name, in any shader stage
</li><li class="listitem">
If any <code class="code">VkSampler</code> object that is accessed from a shader by the
    <code class="code">VkPipeline</code> currently bound to
    <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> uses unnormalized coordinates, it
    <span class="normative">must</span> not be used with any of the SPIR-V <code class="literal">OpImageSample*</code> or
    <code class="literal">OpImageSparseSample*</code> instructions that includes a LOD bias or any
    offset values, in any shader stage
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-robustBufferAccess">robust buffer access</a>
    feature is not enabled, and any shader stage in the <code class="code">VkPipeline</code>
    object currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses
    a uniform buffer, it <span class="normative">must</span> not access values outside of the range of
    that buffer specified in the currently bound descriptor set
</li><li class="listitem">
If the <a class="link" href="ch31s01.html#features-features-robustBufferAccess">robust buffer access</a>
    feature is not enabled, and any shader stage in the <code class="code">VkPipeline</code>
    object currently bound to <code class="code">VK_PIPELINE_BIND_POINT_GRAPHICS</code> accesses
    a storage buffer, it <span class="normative">must</span> not access values outside of the range of
    that buffer specified in the currently bound descriptor set
</li><li class="listitem">
Any <code class="code">VkImageView</code> being sampled with <code class="code">VK_FILTER_LINEAR</code> as a
    result of this command <span class="normative">must</span> be of a format which supports linear
    filtering, as specified by the
    <code class="code">VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT</code> flag in
    <code class="code">VkFormatProperties</code>::<em class="parameter"><code>linearTilingFeatures</code></em> (for a linear
    image) or <code class="code">VkFormatProperties</code>::<em class="parameter"><code>optimalTilingFeatures</code></em>(for an
    optimally tiled image) returned by
    <span class="strong"><strong><code class="code">vkGetPhysicalDeviceFormatProperties</code></strong></span>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage (Implicit)</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be a valid <code class="code">VkCommandBuffer</code> handle
</li><li class="listitem">
<em class="parameter"><code>buffer</code></em> <span class="normative">must</span> be a valid <code class="code">VkBuffer</code> handle
</li><li class="listitem">
<em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be in the recording state
</li><li class="listitem">
The <code class="code">VkCommandPool</code> that <em class="parameter"><code>commandBuffer</code></em> was allocated from <span class="normative">must</span> support graphics operations
</li><li class="listitem">
This command <span class="normative">must</span> only be called inside of a render pass instance
</li><li class="listitem">
Both of <em class="parameter"><code>buffer</code></em>, and <em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> have been created, allocated, or retrieved from the same <code class="code">VkDevice</code>
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Host Synchronization</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Host access to <em class="parameter"><code>commandBuffer</code></em> <span class="normative">must</span> be externally synchronized
</li></ul></div></div><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Command Properties</strong></p></div></div></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; " width="100%"><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Command Buffer Levels</th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top">Render Pass Scope</th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top">Supported Queue Types</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Primary
Secondary</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Inside</p></td><td style="" align="left" valign="top"><p>GRAPHICS</p></td></tr></tbody></table></div></div><p>The <code class="code">VkDrawIndexedIndirectCommand</code> structure is defined as:</p><p><a id="VkDrawIndexedIndirectCommand"></a><strong> </strong>
</p><pre class="programlisting">typedef struct VkDrawIndexedIndirectCommand {
    uint32_t    indexCount;
    uint32_t    instanceCount;
    uint32_t    firstIndex;
    int32_t     vertexOffset;
    uint32_t    firstInstance;
} VkDrawIndexedIndirectCommand;</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<em class="parameter"><code>indexCount</code></em> is the number of vertices to draw.
</li><li class="listitem">
<em class="parameter"><code>instanceCount</code></em> is the number of instances to draw.
</li><li class="listitem">
<em class="parameter"><code>firstIndex</code></em> is the base index within the index buffer.
</li><li class="listitem">
<em class="parameter"><code>vertexOffset</code></em> is the value added to the vertex index before
    indexing into the vertex buffer.
</li><li class="listitem">
<em class="parameter"><code>firstInstance</code></em> is the instance ID of the first instance to draw.
</li></ul></div><p>The members of <code class="code">VkDrawIndexedIndirectCommand</code> have the same meaning as
the similarly named parameters of <code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndexed">vkCmdDrawIndexed</a></code>.</p><div class="sidebar"><div class="titlepage"><div><div><p class="title"><strong>Valid Usage</strong></p></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
For a given vertex buffer binding, any attribute data fetched <span class="normative">must</span> be
    entirely contained within the corresponding vertex buffer binding, as
    described in <a class="xref" href="ch20s02.html" title="20.2. Vertex Input Description">Section 20.2, “Vertex Input Description”</a>
</li><li class="listitem">
(<em class="parameter"><code>indexSize</code></em> * (<em class="parameter"><code>firstIndex</code></em> + <em class="parameter"><code>indexCount</code></em>) + <em class="parameter"><code>offset</code></em>)
    <span class="normative">must</span> be less than or equal to the size of the currently bound index
    buffer, with <em class="parameter"><code>indexSize</code></em> being based on the type specified by
    <em class="parameter"><code>indexType</code></em>, where the index buffer, <em class="parameter"><code>indexType</code></em>, and
    <em class="parameter"><code>offset</code></em> are specified via <span class="strong"><strong><code class="code">vkCmdBindIndexBuffer</code></strong></span>
</li><li class="listitem">
If the
    <a class="link" href="ch31s01.html#features-features-drawIndirectFirstInstance">drawIndirectFirstInstance</a>
    feature is not enabled, <em class="parameter"><code>firstInstance</code></em> <span class="normative">must</span> be <span class="strong"><strong><code class="code">0</code></strong></span>
</li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch19s01.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"><a accesskey="u" href="ch19.html"><img src="images/icons/up.png" alt="Up" /></a></td><td width="40%" align="right"> <a accesskey="n" href="ch20.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>