<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.6. Built-In Variables</title><link rel="stylesheet" type="text/css" href="config/vkspec-xhtml.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Vulkan 1.0.30 - A Specification (with WSI extensions)" /><link rel="up" href="ch14.html" title="Chapter 14. Shader Interfaces" /><link rel="prev" href="ch14s05.html" title="14.5. Shader Resource Interface" /><link rel="next" href="ch15.html" title="Chapter 15. Image Operations" /><script xmlns="" type="text/x-mathjax-config">
        MathJax.Hub.Config({
            MathML: { extensions: ["content-mathml.js"] },
            tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] }
        });
    </script><script xmlns="" type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="ch14s05.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ch15.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr></table><hr /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="interfaces-builtin-variables"></a>14.6. Built-In Variables</h2></div></div></div><p>Built-in variables are accessed in shaders by declaring a variable decorated
with a <span class="strong"><strong><code class="code">BuiltIn</code></strong></span> decoration.
The meaning of each <span class="strong"><strong><code class="code">BuiltIn</code></strong></span> decoration is as follows.
In the remainder of this section, the name of a built-in is used
interchangeably with a term equivalent to a variable decorated with that
particular built-in.
Built-ins that represent integer values <span class="normative">can</span> be declared as either signed or
unsigned 32-bit integers.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">ClipDistance</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">ClipDistance</code></strong></span> built-in decoration will
make that variable contain the mechanism for controlling user clipping.
<span class="strong"><strong><code class="code">ClipDistance</code></strong></span> is an array such that the i<sup>th</sup> element of the array
specifies the clip distance for plane i.
A clip distance of 0 means the vertex is on the plane, a positive distance
means the vertex is inside the clip half-space, and a negative distance
means the point is outside the clip half-space.
</p><p class="simpara">The <span class="strong"><strong><code class="code">ClipDistance</code></strong></span> decoration <span class="normative">must</span> be used only within vertex, fragment,
tessellation control, tessellation evaluation, and geometry shaders.</p><p class="simpara">In vertex shaders, any variable decorated with <span class="strong"><strong><code class="code">ClipDistance</code></strong></span> <span class="normative">must</span> be
declared using the output storage class.</p><p class="simpara">In fragment shaders, any variable decorated with <span class="strong"><strong><code class="code">ClipDistance</code></strong></span> <span class="normative">must</span> be
declared using the input storage class.</p><p class="simpara">In tessellation control, tessellation evaluation, or geometry shaders, any
variable decorated with <span class="strong"><strong><code class="code">ClipDistance</code></strong></span> <span class="normative">must</span> not be in a storage class
other than input or output.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">ClipDistance</code></strong></span> <span class="normative">must</span> be declared as an array
of 32-bit floating-point values.</p></dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>The array variable decorated with <span class="strong"><strong><code class="code">ClipDistance</code></strong></span> is explicitly sized by
the shader.</p></td></tr></table></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In the last vertex processing stage, these values will be linearly
interpolated across the primitive and the portion of the primitive with
interpolated distances less than 0 will be considered outside the clip
volume.
If <span class="strong"><strong><code class="code">ClipDistance</code></strong></span> is then used by a fragment shader, <span class="strong"><strong><code class="code">ClipDistance</code></strong></span>
contains these linearly interpolated values.</p></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">CullDistance</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">CullDistance</code></strong></span> built-in decoration will
make that variable contain the mechanism for controlling user culling.
If any member of this array is assigned a negative value for all vertices
belonging to a primitive, then the primitive is discarded before
rasterization.
</p><p class="simpara">The <span class="strong"><strong><code class="code">CullDistance</code></strong></span> decoration <span class="normative">must</span> be used only within vertex, fragment,
tessellation control, tessellation evaluation, and geometry shaders.</p><p class="simpara">In vertex shaders, any variable decorated with <span class="strong"><strong><code class="code">CullDistance</code></strong></span> <span class="normative">must</span> be
declared using the output storage class.</p><p class="simpara">In fragment shaders, any variable decorated with <span class="strong"><strong><code class="code">CullDistance</code></strong></span> <span class="normative">must</span> be
declared using the input storage class.</p><p class="simpara">In tessellation control, tessellation evaluation, or geometry shaders, any
variable decorated with <span class="strong"><strong><code class="code">CullDistance</code></strong></span> <span class="normative">must</span> not be declared in a storage
class other than input or output.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">CullDistance</code></strong></span> <span class="normative">must</span> be declared as an array
of 32-bit floating-point values.</p></dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>In fragment shaders, the values of the <span class="strong"><strong><code class="code">CullDistance</code></strong></span> array are linearly
interpolated across each primitive.</p></td></tr></table></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If <span class="strong"><strong><code class="code">CullDistance</code></strong></span> decorates an input variable, that variable will contain
the corresponding value from the <span class="strong"><strong><code class="code">CullDistance</code></strong></span> decorated output variable
from the previous shader stage.</p></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">FragCoord</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">FragCoord</code></strong></span> built-in decoration will make
that variable contain the framebuffer coordinate
<span class="inlinemediaobject"><span class="phrase">
$(x,y,z,\frac{1}{w})$
</span></span> of the fragment being processed.
The <span class="eq">(x,y)</span> coordinate <span class="eq">(0,0)</span> is the upper left corner of the upper
left pixel in the framebuffer.
</p><p class="simpara">When sample shading is enabled, the <span class="eq">x</span> and <span class="eq">y</span> components of
<span class="strong"><strong><code class="code">FragCoord</code></strong></span> reflect the location of the sample corresponding to the
shader invocation.</p><p class="simpara">When sample shading is not enabled, the x and y components of <span class="strong"><strong><code class="code">FragCoord</code></strong></span>
reflect the location of the center of the pixel, <span class="eq">(0.5,0.5)</span>.</p><p class="simpara">The <span class="eq">z</span> component of <span class="strong"><strong><code class="code">FragCoord</code></strong></span> is the interpolated depth value of
the primitive.</p><p class="simpara">The <span class="eq">w</span> component is the interpolated <span class="inlinemediaobject"><span class="phrase">
$\frac{1}{w}$
</span></span>.</p><p class="simpara">The <span class="strong"><strong><code class="code">FragCoord</code></strong></span> decoration <span class="normative">must</span> be used only within fragment shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">FragCoord</code></strong></span> <span class="normative">must</span> be declared using the input
storage class.</p><p class="simpara">The <span class="strong"><strong><code class="code">Centroid</code></strong></span> interpolation decoration is ignored on <span class="strong"><strong><code class="code">FragCoord</code></strong></span>.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">FragCoord</code></strong></span> <span class="normative">must</span> be declared as a
four-component vector of 32-bit floating-point values.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">FragDepth</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">FragDepth</code></strong></span> built-in decoration will make
that variable contain the new depth value for all samples covered by the
fragment.
This value will be used for depth testing and, if the depth test passes, any
subsequent write to the depth/stencil attachment.
</p><p class="simpara">To write to <span class="strong"><strong><code class="code">FragDepth</code></strong></span>, a shader <span class="normative">must</span> declare the <span class="strong"><strong><code class="code">DepthReplacing</code></strong></span>
execution mode.
If a shader declares the <span class="strong"><strong><code class="code">DepthReplacing</code></strong></span> execution mode and there is an
execution path through the shader that does not set <span class="strong"><strong><code class="code">FragDepth</code></strong></span>, then the
fragment’s depth value is undefined for executions of the shader that take
that path.</p><p class="simpara">The <span class="strong"><strong><code class="code">FragDepth</code></strong></span> decoration <span class="normative">must</span> be used only within fragment shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">FragDepth</code></strong></span> <span class="normative">must</span> be declared using the
output storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">FragDepth</code></strong></span> <span class="normative">must</span> be declared as a scalar
32-bit floating-point value.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">FrontFacing</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">FrontFacing</code></strong></span> built-in decoration will
make that variable contain whether a primitive is front or back facing.
This variable is non-zero if the current fragment is considered to be part
of a <a class="link" href="ch24s07.html#primsrast-polygons-basic" title="24.7.1. Basic Polygon Rasterization">front-facing</a> primitive and is zero if the
fragment is considered to be part of a back-facing primitive.
</p><p class="simpara">The <span class="strong"><strong><code class="code">FrontFacing</code></strong></span> decoration <span class="normative">must</span> be used only within fragment shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">FrontFacing</code></strong></span> <span class="normative">must</span> be declared using the
input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">FrontFacing</code></strong></span> <span class="normative">must</span> be declared as a boolean.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">GlobalInvocationId</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">GlobalInvocationId</code></strong></span> built-in decoration
will make that variable contain the location of the current invocation
within the global workgroup.
Each component is equal to the index of the local workgroup multiplied by
the size of the local workgroup plus <span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span>.
</p><p class="simpara">The <span class="strong"><strong><code class="code">GlobalInvocationId</code></strong></span> decoration <span class="normative">must</span> be used only within compute
shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">GlobalInvocationId</code></strong></span> <span class="normative">must</span> be declared using
the input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">GlobalInvocationId</code></strong></span> <span class="normative">must</span> be declared as a
three-component vector of 32-bit integers.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">HelperInvocation</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">HelperInvocation</code></strong></span> built-in decoration
will make that variable contain whether the current invocation is a helper
invocation.
This variable is non-zero if the current fragment being shaded is a helper
invocation and zero otherwise.
A helper invocation is an invocation of the shader that is produced to
satisfy internal requirements such as the generation of derivatives.
</p><p class="simpara">The <span class="strong"><strong><code class="code">HelperInvocation</code></strong></span> decoration <span class="normative">must</span> be used only within fragment
shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">HelperInvocation</code></strong></span> <span class="normative">must</span> be declared using
the input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">HelperInvocation</code></strong></span> <span class="normative">must</span> be declared as a
boolean.</p></dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>It is very likely that a helper invocation will have a value of
<span class="strong"><strong><code class="code">SampleMask</code></strong></span> fragment shader input value that is zero.</p></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">InvocationId</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">InvocationId</code></strong></span> built-in decoration will
make that variable contain the index of the current shader invocation in a
geometry shader, or the index of the output patch vertex in a tessellation
control shader.
</p><p class="simpara">In a geometry shader, the index of the current shader invocation ranges from
zero to the number of <a class="link" href="ch22s03.html" title="22.3. Multiple Invocations of Geometry Shaders">instances</a> declared in the
shader minus one.
If the instance count of the geometry shader is one or is not specified,
then <span class="strong"><strong><code class="code">InvocationId</code></strong></span> will be zero.</p><p class="simpara">The <span class="strong"><strong><code class="code">InvocationId</code></strong></span> decoration <span class="normative">must</span> be used only within tessellation
control and geometry shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">InvocationId</code></strong></span> <span class="normative">must</span> be declared using the
input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">InvocationId</code></strong></span> <span class="normative">must</span> be declared as a scalar
32-bit integer.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">InstanceIndex</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">InstanceIndex</code></strong></span> built-in decoration will
make that variable contain the index of the instance that is being processed
by the current vertex shader invocation.
<span class="strong"><strong><code class="code">InstanceIndex</code></strong></span> begins at the <em class="parameter"><code>firstInstance</code></em> parameter to
<code class="code"><a class="link" href="ch19s02.html#vkCmdDraw">vkCmdDraw</a></code> or <code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndexed">vkCmdDrawIndexed</a></code> or at the <em class="parameter"><code>firstInstance</code></em>
member of a structure consumed by <code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndirect">vkCmdDrawIndirect</a></code> or
<code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndexedIndirect">vkCmdDrawIndexedIndirect</a></code>.
</p><p class="simpara">The <span class="strong"><strong><code class="code">InstanceIndex</code></strong></span> decoration <span class="normative">must</span> be used only within vertex shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">InstanceIndex</code></strong></span> <span class="normative">must</span> be declared using the
input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">InstanceIndex</code></strong></span> <span class="normative">must</span> be declared as a scalar
32-bit integer.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">Layer</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">Layer</code></strong></span> built-in decoration will make that
variable contain the select layer of a multi-layer framebuffer attachment.
</p><p class="simpara">In a geometry shader, any variable decorated with <span class="strong"><strong><code class="code">Layer</code></strong></span> can be written
with the framebuffer layer index to which the primitive produced by the
geometry shader will be directed.
If a geometry shader entry point’s interface does not include a variable
decorated with <span class="strong"><strong><code class="code">Layer</code></strong></span>, then the first layer is used.
If a geometry shader entry point’s interface includes a variable decorated
with <span class="strong"><strong><code class="code">Layer</code></strong></span>, it <span class="normative">must</span> write the same value to <span class="strong"><strong><code class="code">Layer</code></strong></span> for all output
vertices of a given primitive.</p><p class="simpara">In a fragment shader, a variable decorated with <span class="strong"><strong><code class="code">Layer</code></strong></span> contains the
layer index of the primitive that the fragment invocation belongs to.</p><p class="simpara">The <span class="strong"><strong><code class="code">Layer</code></strong></span> decoration <span class="normative">must</span> be used only within geometry and fragment
shaders.</p><p class="simpara">In a geometry shader, any variable decorated with <span class="strong"><strong><code class="code">Layer</code></strong></span> <span class="normative">must</span> be
declared using the output storage class.</p><p class="simpara">In a fragment shader, any variable decorated with <span class="strong"><strong><code class="code">Layer</code></strong></span> <span class="normative">must</span> be
declared using the input storage class.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">Layer</code></strong></span> <span class="normative">must</span> be declared as a scalar 32-bit
integer.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span> built-in decoration
will make that variable contain the location of the current compute shader
invocation within the local workgroup.
Each component ranges from zero through to the size of the workgroup in that
dimension minus one.
</p><p class="simpara">The <span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span> decoration <span class="normative">must</span> be used only within compute
shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span> <span class="normative">must</span> be declared using
the input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span> <span class="normative">must</span> be declared as a
three-component vector of 32-bit integers.</p></dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>If the size of the workgroup in a particular dimension is one, then the
<span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span> in that dimension will be zero.
If the workgroup is effectively two-dimensional, then
<span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span>.z will be zero.
If the workgroup is effectively one-dimensional, then both
<span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span>.y and <span class="strong"><strong><code class="code">LocalInvocationId</code></strong></span>.z will be zero.</p></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">NumWorkgroups</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">NumWorkgroups</code></strong></span> built-in decoration will
make that variable contain the number of local workgroups that are part of
the dispatch that the invocation belongs to.
Each component is equal to the values of the parameters passed into
<code class="code"><a class="link" href="ch27.html#vkCmdDispatch">vkCmdDispatch</a></code> or read from the <code class="code">VkDispatchIndirectCommand</code>
structure read through a call to <code class="code"><a class="link" href="ch27.html#vkCmdDispatchIndirect">vkCmdDispatchIndirect</a></code>.
</p><p class="simpara">The <span class="strong"><strong><code class="code">NumWorkgroups</code></strong></span> decoration <span class="normative">must</span> be used only within compute shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">NumWorkgroups</code></strong></span> <span class="normative">must</span> be declared using the
input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">NumWorkgroups</code></strong></span> <span class="normative">must</span> be declared as a
three-component vector of 32-bit integers.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">PatchVertices</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">PatchVertices</code></strong></span> built-in decoration will
make that variable contain the number of vertices in the input patch being
processed by the shader.
A single tessellation control or tessellation evaluation shader <span class="normative">can</span> read
patches of differing sizes, so the value of the <span class="strong"><strong><code class="code">PatchVertices</code></strong></span> variable
<span class="normative">may</span> differ between patches.
</p><p class="simpara">The <span class="strong"><strong><code class="code">PatchVertices</code></strong></span> decoration <span class="normative">must</span> be used only within tessellation
control and tessellation evaluation shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">PatchVertices</code></strong></span> <span class="normative">must</span> be declared using the
input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">PatchVertices</code></strong></span> <span class="normative">must</span> be declared as scalar
32-bit integer.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">PointCoord</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">PointCoord</code></strong></span> built-in decoration will make
that variable contain the coordinate of the current fragment within the
point being rasterized, normalized to the size of the point with origin in
the upper left corner of the point, as described in
<a class="link" href="ch24s05.html#primsrast-points-basic" title="24.5.1. Basic Point Rasterization">Basic Point Rasterization</a>.
If the primitive the fragment shader invocation belongs to is not a point,
then the variable decorated with <span class="strong"><strong><code class="code">PointCoord</code></strong></span> contains an undefined
value.
</p><p class="simpara">The <span class="strong"><strong><code class="code">PointCoord</code></strong></span> decoration <span class="normative">must</span> be used only within fragment shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">PointCoord</code></strong></span> <span class="normative">must</span> be declared using the
input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">PointCoord</code></strong></span> <span class="normative">must</span> be declared as
two-component vector of 32-bit floating-point values.</p></dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Depending on how the point is rasterized, <span class="strong"><strong><code class="code">PointCoord</code></strong></span> <span class="normative">may</span> never reach
<span class="eq">(0,0)</span> or <span class="eq">(1,1)</span>.</p></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">PointSize</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">PointSize</code></strong></span> built-in decoration will make
that variable contain the size of point primitives.
The value written to the variable decorated with <span class="strong"><strong><code class="code">PointSize</code></strong></span> by the last
vertex processing stage in the pipeline is used as the framebuffer-space
size of points produced by rasterization.
</p><p class="simpara">The <span class="strong"><strong><code class="code">PointSize</code></strong></span> decoration <span class="normative">must</span> be used only within vertex, tessellation
control, tessellation evaluation, and geometry shaders.</p><p class="simpara">In a vertex shader, any variable decorated with <span class="strong"><strong><code class="code">PointSize</code></strong></span> <span class="normative">must</span> be
declared using the output storage class.</p><p class="simpara">In a tessellation control, tessellation evaluation, or geometry shader, any
variable decorated with <span class="strong"><strong><code class="code">PointSize</code></strong></span> <span class="normative">must</span> be declared using either the
input or output storage class.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">PointSize</code></strong></span> <span class="normative">must</span> be declared as a scalar
32-bit floating-point value.</p></dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When <span class="strong"><strong><code class="code">PointSize</code></strong></span> decorates a variable in the input storage class, it
contains the data written to the output variable decorated with
<span class="strong"><strong><code class="code">PointSize</code></strong></span> from the previous shader stage.</p></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">Position</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">Position</code></strong></span> built-in decoration will make
that variable contain the position of the current vertex.
In the last vertex processing stage, the value of the variable decorated
with <span class="strong"><strong><code class="code">Position</code></strong></span> is used in subsequent primitive assembly, clipping, and
rasterization operations.
</p><p class="simpara">The <span class="strong"><strong><code class="code">Position</code></strong></span> decoration <span class="normative">must</span> be used only within vertex, tessellation
control, tessellation evaluation, and geometry shaders.</p><p class="simpara">In a vertex shader, any variable decorated with <span class="strong"><strong><code class="code">Position</code></strong></span> <span class="normative">must</span> be
declared using the output storage class.</p><p class="simpara">In a tessellation control, tessellation evaluation, or geometry shader, any
variable decorated with <span class="strong"><strong><code class="code">Position</code></strong></span> <span class="normative">must</span> not be declared in a storage
class other than input or output.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">Position</code></strong></span> <span class="normative">must</span> be declared as a
four-component vector of 32-bit floating-point values.</p></dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When <span class="strong"><strong><code class="code">Position</code></strong></span> decorates a variable in the input storage class, it
contains the data written to the output variable decorated with
<span class="strong"><strong><code class="code">Position</code></strong></span> from the previous shader stage.</p></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">PrimitiveId</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">PrimitiveId</code></strong></span> built-in decoration will
make that variable contain the index of the current primitive.
</p><p class="simpara">In tessellation control and tessellation evaluation shaders, it will contain
the index of the patch within the current set of rendering primitives that
correspond to the shader invocation.</p><p class="simpara">In a geometry shader, it will contain the number of primitives presented as
input to the shader since the current set of rendering primitives was
started.</p><p class="simpara">In a fragment shader, it will contain the primitive index written by the
geometry shader if a geometry shader is present, or with the value that
would have been presented as input to the geometry shader had it been
present.</p><p class="simpara">If a geometry shader is present and the fragment shader reads from an input
variable decorated with <span class="strong"><strong><code class="code">PrimitiveId</code></strong></span>, then the geometry shader <span class="normative">must</span>
write to an output variable decorated with <span class="strong"><strong><code class="code">PrimitiveId</code></strong></span> in all execution
paths.</p><p class="simpara">The <span class="strong"><strong><code class="code">PrimitiveId</code></strong></span> decoration <span class="normative">must</span> be used only within fragment,
tessellation control, tessellation evaluation, and geometry shaders.</p><p class="simpara">In a fragment, tessellation control or tessellation evaluation shader, any
variable decorated with <span class="strong"><strong><code class="code">PrimitiveId</code></strong></span> <span class="normative">must</span> be declared using the output
storage class.</p><p class="simpara">In a geometry shader, any variable decorated with <span class="strong"><strong><code class="code">PrimitiveId</code></strong></span> <span class="normative">must</span> be
declared using either the input or output storage class.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">PrimitiveId</code></strong></span> <span class="normative">must</span> be declared as scalar
32-bit integer.</p></dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>When the <span class="strong"><strong><code class="code">PrimitiveId</code></strong></span> decoration is applied to an output variable in the
geometry shader, the resulting value is seen through the <span class="strong"><strong><code class="code">PrimitiveId</code></strong></span>
decorated input variable in the fragment shader.</p></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">SampleId</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">SampleId</code></strong></span> built-in decoration will make
that variable contain the zero-based index of the sample the invocation
corresponds to.
<span class="strong"><strong><code class="code">SampleId</code></strong></span> ranges from zero to the number of samples in the framebuffer
minus one.
If a fragment shader entry point’s interface includes an input variable
decorated with <span class="strong"><strong><code class="code">SampleId</code></strong></span>, per-sample shading is enabled for draws that
use that fragment shader.
</p><p class="simpara">The <span class="strong"><strong><code class="code">SampleId</code></strong></span> decoration <span class="normative">must</span> be used only within fragment shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">SampleId</code></strong></span> <span class="normative">must</span> be declared using the input
storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">SampleId</code></strong></span> <span class="normative">must</span> be declared as a scalar
32-bit integer.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">SampleMask</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">SampleMask</code></strong></span> built-in decoration will make
any variable contain the sample coverage mask for the current fragment
shader invocation.
</p><p class="simpara">A variable in the input storage class decorated with <span class="strong"><strong><code class="code">SampleMask</code></strong></span> will
contain a bitmask of the set of samples covered by the primitive generating
the fragment during rasterization.
It has a sample bit set if and only if the sample is considered covered for
this fragment shader invocation.
<span class="strong"><strong><code class="code">SampleMask</code></strong></span>[] is an array of integers.
Bits are mapped to samples in a manner where bit B of mask M
(<code class="literal">SampleMask[M]</code>) corresponds to sample <span class="eq">32 × M + B</span>.</p><p class="simpara">When state specifies multiple fragment shader invocations for a given
fragment, the sample mask for any single fragment shader invocation
specifies the subset of the covered samples for the fragment that correspond
to the invocation.
In this case, the bit corresponding to each covered sample will be set in
exactly one fragment shader invocation.</p><p class="simpara">A variable in the output storage class decorated with <span class="strong"><strong><code class="code">SampleMask</code></strong></span> is an
array of integers forming a bit array in a manner similar an input variable
decorated with <span class="strong"><strong><code class="code">SampleMask</code></strong></span>, but where each bit represents coverage as
computed by the shader.
Modifying the sample mask by writing zero to a bit of <span class="strong"><strong><code class="code">SampleMask</code></strong></span> causes
the sample to be considered uncovered.
However, setting sample mask bits to one will never enable samples not
covered by the original primitive.
If the fragment shader is being evaluated at any frequency other than
per-fragment, bits of the sample mask not corresponding to the current
fragment shader invocation are ignored.
This array <span class="normative">must</span> be sized in the fragment shader either implicitly or
explicitly, to be no larger than the implementation-dependent maximum
sample-mask (as an array of 32-bit elements), determined by the maximum
number of samples.
If a fragment shader entry point’s interface includes an output variable
decorated with <span class="strong"><strong><code class="code">SampleMask</code></strong></span>, the sample mask will be undefined for any
array elements of any fragment shader invocations that fail to assign a
value.
If a fragment shader entry point’s interface does not include an output
variable decorated with <span class="strong"><strong><code class="code">SampleMask</code></strong></span>, the sample mask has no effect on
the processing of a fragment.</p><p class="simpara">The <span class="strong"><strong><code class="code">SampleMask</code></strong></span> decoration <span class="normative">must</span> be used only within fragment shaders.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">SampleMask</code></strong></span> <span class="normative">must</span> be declared using either
the input or output storage class.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">SampleMask</code></strong></span> <span class="normative">must</span> be declared as an array of
32-bit integers.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">SamplePosition</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">SamplePosition</code></strong></span> built-in decoration will
make that variable contain the sub-pixel position of the sample being
shaded.
The top left of the pixel is considered to be at coordinate <span class="eq">(0,0)</span> and
the bottom right of the pixel is considered to be at coordinate <span class="eq">(1,1)</span>.
If a fragment shader entry point’s interface includes an input variable
decorated with <span class="strong"><strong><code class="code">SamplePosition</code></strong></span>, per-sample shading is enabled for draws
that use that fragment shader.
</p><p class="simpara">The <span class="strong"><strong><code class="code">SamplePosition</code></strong></span> decoration <span class="normative">must</span> be used only within fragment
shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">SamplePosition</code></strong></span> <span class="normative">must</span> be declared using the
input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">SamplePosition</code></strong></span> <span class="normative">must</span> be declared as a
two-component vector of 32-bit floating-point values.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">TessCoord</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">TessCoord</code></strong></span> built-in decoration will make
that variable contain the three-dimensional <span class="eq">(u,v,w)</span> barycentric
coordinate of the tessellated vertex within the patch.
<span class="eq">u</span>, <span class="eq">v</span>, and <span class="eq">w</span> are in the range <span class="eq">[0,1]</span> and vary linearly
across the primitive being subdivided.
For the tessellation modes of <span class="strong"><strong><code class="code">Quads</code></strong></span> or <span class="strong"><strong><code class="code">IsoLines</code></strong></span>, the third
component is always zero.
</p><p class="simpara">The <span class="strong"><strong><code class="code">TessCoord</code></strong></span> decoration <span class="normative">must</span> be used only within tessellation
evaluation shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">TessCoord</code></strong></span> <span class="normative">must</span> be declared using the input
storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">TessCoord</code></strong></span> <span class="normative">must</span> be declared as
three-component vector of 32-bit floating-point values.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">TessLevelOuter</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">TessLevelOuter</code></strong></span> built-in decoration will
make that variable contain the outer tessellation levels for the current
patch.
</p><p class="simpara">In tessellation control shaders, the variable decorated with
<span class="strong"><strong><code class="code">TessLevelOuter</code></strong></span> <span class="normative">can</span> be written to which controls the tessellation
factors for the resulting patch.
These values are used by the tessellator to control primitive tessellation
and <span class="normative">can</span> be read by tessellation evaluation shaders.</p><p class="simpara">In tessellation evaluation shaders, the variable decorated with
<span class="strong"><strong><code class="code">TessLevelOuter</code></strong></span> <span class="normative">can</span> read the values written by the tessellation control
shader.</p><p class="simpara">The <span class="strong"><strong><code class="code">TessLevelOuter</code></strong></span> decoration <span class="normative">must</span> be used only within tessellation
control and tessellation evaluation shaders.</p><p class="simpara">In a tessellation control shader, any variable decorated with
<span class="strong"><strong><code class="code">TessLevelOuter</code></strong></span> <span class="normative">must</span> be declared using the output storage class.</p><p class="simpara">In a tessellation evaluation shader, any variable decorated with
<span class="strong"><strong><code class="code">TessLevelOuter</code></strong></span> <span class="normative">must</span> be declared using the input storage class.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">TessLevelOuter</code></strong></span> <span class="normative">must</span> be declared as an
array of size four, containing 32-bit floating-point values.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">TessLevelInner</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">TessLevelInner</code></strong></span> built-in decoration will
make that variable contain the inner tessellation levels for the current
patch.
</p><p class="simpara">In tessellation control shaders, the variable decorated with
<span class="strong"><strong><code class="code">TessLevelInner</code></strong></span> <span class="normative">can</span> be written to, which controls the tessellation
factors for the resulting patch.
These values are used by the tessellator to control primitive tessellation
and <span class="normative">can</span> be read by tessellation evaluation shaders.</p><p class="simpara">In tessellation evaluation shaders, the variable decorated with
<span class="strong"><strong><code class="code">TessLevelInner</code></strong></span> <span class="normative">can</span> read the values written by the tessellation control
shader.</p><p class="simpara">The <span class="strong"><strong><code class="code">TessLevelInner</code></strong></span> decoration <span class="normative">must</span> be used only within tessellation
control and tessellation evaluation shaders.</p><p class="simpara">In a tessellation control shader, any variable decorated with
<span class="strong"><strong><code class="code">TessLevelInner</code></strong></span> <span class="normative">must</span> be declared using the output storage class.</p><p class="simpara">In a tessellation evaluation shader, any variable decorated with
<span class="strong"><strong><code class="code">TessLevelInner</code></strong></span> <span class="normative">must</span> be declared using the input storage class.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">TessLevelInner</code></strong></span> <span class="normative">must</span> be declared as an
array of size two, containing 32-bit floating-point values.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">VertexIndex</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">VertexIndex</code></strong></span> built-in decoration will
make that variable contain the index of the vertex that is being processed
by the current vertex shader invocation.
For non-indexed draws, this variable begins at the <em class="parameter"><code>firstVertex</code></em>
parameter to <code class="code"><a class="link" href="ch19s02.html#vkCmdDraw">vkCmdDraw</a></code> or the <em class="parameter"><code>firstVertex</code></em> member of a structure
consumed by <code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndirect">vkCmdDrawIndirect</a></code> and increments by one for each vertex in
the draw.
For indexed draws, its value is the content of the index buffer for the
vertex plus the <em class="parameter"><code>vertexOffset</code></em> parameter to <code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndexed">vkCmdDrawIndexed</a></code> or
the <em class="parameter"><code>vertexOffset</code></em> member of the structure consumed by
<code class="code"><a class="link" href="ch19s02.html#vkCmdDrawIndexedIndirect">vkCmdDrawIndexedIndirect</a></code>.
</p><p class="simpara">The <span class="strong"><strong><code class="code">VertexIndex</code></strong></span> decoration <span class="normative">must</span> be used only within vertex shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">VertexIndex</code></strong></span> <span class="normative">must</span> be declared using the
input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">VertexIndex</code></strong></span> <span class="normative">must</span> be declared as a scalar
32-bit integer.</p></dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><table border="0" summary="Note: Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/icons/note.png" /></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p><span class="strong"><strong><code class="code">VertexIndex</code></strong></span> starts at the same starting value for each instance.</p></td></tr></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong><code class="code">ViewportIndex</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span> built-in decoration will
make that variable contain the index of the viewport.
</p><p class="simpara">In a geometry shader, the variable decorated with <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span> can be
written to with the viewport index to which the primitive produced by the
geometry shader will be directed.
The selected viewport index is used to select the viewport transform and
scissor rectangle.
If a geometry shader entry point’s interface does not include a variable
decorated with <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span>, then the first viewport is used.
If a geometry shader entry point’s interface includes a variable decorated
with <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span>, it <span class="normative">must</span> write the same value to <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span>
for all output vertices of a given primitive.</p><p class="simpara">In a fragment shader, the variable decorated with <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span>
contains the viewport index of the primitive that the fragment invocation
belongs to.</p><p class="simpara">The <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span> decoration <span class="normative">must</span> be used only within geometry and
fragment shaders.</p><p class="simpara">In a geometry shader, any variable decorated with <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span> <span class="normative">must</span>
be declared using the output storage class.</p><p class="simpara">In a fragment shader, any variable decorated with <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span> <span class="normative">must</span>
be declared using the input storage class.</p><p class="simpara">Any variable decorated with <span class="strong"><strong><code class="code">ViewportIndex</code></strong></span> <span class="normative">must</span> be declared as a scalar
32-bit integer.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">WorkgroupId</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">WorkgroupId</code></strong></span> built-in decoration will
make that variable contain the global workgroup that the current invocation
is a member of.
Each component ranges from zero to the values of the parameters passed into
<code class="code"><a class="link" href="ch27.html#vkCmdDispatch">vkCmdDispatch</a></code> or read from the <code class="code">VkDispatchIndirectCommand</code>
structure read through a call to <code class="code"><a class="link" href="ch27.html#vkCmdDispatchIndirect">vkCmdDispatchIndirect</a></code>.
</p><p class="simpara">The <span class="strong"><strong><code class="code">WorkgroupId</code></strong></span> decoration <span class="normative">must</span> be used only within compute shaders.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">WorkgroupId</code></strong></span> <span class="normative">must</span> be declared using the
input storage class.</p><p class="simpara">The variable decorated with <span class="strong"><strong><code class="code">WorkgroupId</code></strong></span> <span class="normative">must</span> be declared as a
three-component vector of 32-bit integers.</p></dd><dt><span class="term">
<span class="strong"><strong><code class="code">WorkgroupSize</code></strong></span>
</span></dt><dd><p class="simpara">
Decorating a variable with the <span class="strong"><strong><code class="code">WorkgroupSize</code></strong></span> built-in decoration will
make that variable contain the dimensions of a local workgroup.
If an object is decorated with the <span class="strong"><strong><code class="code">WorkgroupSize</code></strong></span> decoration, this <span class="normative">must</span>
take precedence over any execution mode set for <span class="strong"><strong><code class="code">LocalSize</code></strong></span>.
</p><p class="simpara">The <span class="strong"><strong><code class="code">WorkgroupSize</code></strong></span> decoration <span class="normative">must</span> be used only within compute shaders.</p><p class="simpara">The object decorated with <span class="strong"><strong><code class="code">WorkgroupSize</code></strong></span> <span class="normative">must</span> be a specialization
constant or a constant.</p><p class="simpara">The object decorated with <span class="strong"><strong><code class="code">WorkgroupSize</code></strong></span> <span class="normative">must</span> be declared as a
three-component vector of 32-bit integers.</p></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch14s05.html"><img src="images/icons/prev.png" alt="Prev" /></a> </td><td width="20%" align="center"><a accesskey="u" href="ch14.html"><img src="images/icons/up.png" alt="Up" /></a></td><td width="40%" align="right"> <a accesskey="n" href="ch15.html"><img src="images/icons/next.png" alt="Next" /></a></td></tr><tr><td width="40%" align="left" valign="top"> </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/icons/home.png" alt="Home" /></a></td><td width="40%" align="right" valign="top"> </td></tr></table></div></body></html>