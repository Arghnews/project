Problem: Now with deceleration from the world that is proportional to square to speed, if you simulate at 60 fps, you will get a deceleration from the world (simulating loss of inertia due to air resistance, friction etc) 60 times a second, whereas if you're on 30 fps you get this 30 times a second. Whilst framerate is decoupled somewhat from movement, this only works when adding velocity to displacement every frame because this is a linear increase, so adding double the velocity every 1/30th of a second to the object's position/displacement works the same as adding it's velocity every 1/60th of a second. I cannot see an easy way to make this work however when the quantities are not linear, ie. when the deceleration is proportional to a square.
Proposed solution: Completely decouple tickrate of the world simulation from the framerate. Have two separate objects for tick and framerate. Tick object will be (to start) locked at 60 ticks per second. Tickrate object should keep it's own time as a float, as well as an integer that should decide what tick it is on. Framerate can also keep it's own framecounter. This should allow the world to only be simulated every 60 ticks. Problem with this is that if tickrate is increased this will change how the world behaves, ie back to original problem. The other issue is how can players with fps > tickrate get an improved experience if the world is only changed on tickrate. This could be solved: player at 120fps vs server at 60 tick, player moving from position (consider 1D only) 1 to 2. Tick 1, server simulates world, knows where player is and where player will end up. Frame 1, player knows their velocity/position at that point, is simulated as normal. Now at frame 2, server still on tick 1, player wants to be rendered again. The player's position at any point during that tick is known, since their velocity/accel etc for that tick is effectively constant, ie it will not change until next tick. So can simply set player's position to be halfway between 1 and 2 on our axis, ie. 1.5. Or final position = (initial position + final position)/2, where 2 is framerate/tickrate. Note when player's framerate <= server tickrate, this 'interpolation' should not be used.

v(t) = v0 + at
s(t) = v0 + 1/2at^2 +c
here the tricky bit is that a is of two components (for forward motion, simple example)
a = (forward force + backward force)/mass   --   ignoring mass for now
forward force is constant accel, easy enough just a number
backward force, to stop stuff either not moving or flying off forever, is like a drag force
ie. backward force = deltaTime*(velo.x*velo.x*worldDecelv.x + decelConst), worldDecelv.x is just a multiplied constant, varying it changes object's terminal velocity

First going to move any framerate based timers etc into the Framerates class
Split frame and tickrate. Physics now has x^2 and x decel terms.
